function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var MOVES_REGEXP = /([RLUDFB]w?|[rludfbMSExyz])2?'?/g;
var stringToMoves = function stringToMoves(string) {
  if (!string) return [];
  var preformatted = string.replace(/\s+/g, '').replace(/`/g, "'").replace(/[XYZ]/g, function (rotation) {
    return rotation.toLowerCase();
  });
  return preformatted.match(MOVES_REGEXP) || [];
};
var invertMove = function invertMove(move) {
  return move.match(/(2|')$/) ? move.replace("'", '') : move + "'";
};
var doubleMove = function doubleMove(move) {
  return move.replace(/2?'?$/, '2');
};

var flatMap = function flatMap(arr, fn) {
  return arr.reduce(function (xs, x) {
    return xs.concat(fn(x));
  }, []);
};
var fromPairs = function fromPairs(arr) {
  return arr.reduce(function (obj, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    return _objectSpread({}, obj, _defineProperty({}, key, value));
  }, {});
};
var intersection = function intersection(xs, ys) {
  return xs.filter(function (x) {
    return ys.includes(x);
  });
};
var maxBy = function maxBy(arr, fn) {
  return arr.reduce(function (x, y) {
    return fn(y) > fn(x) ? y : x;
  });
};
var reverse = function reverse(str) {
  return str.split('').reverse().join('');
};
var rotate = function rotate(arr, n) {
  return arr.slice(n).concat(arr.slice(0, n));
};
var splitWith = function splitWith(arr, predicate) {
  var index = arr.findIndex(predicate);
  var splitIndex = index === -1 ? arr.length : index;
  return [arr.slice(0, splitIndex), arr.slice(splitIndex)];
};
var zip = function zip() {
  for (var _len = arguments.length, arrs = new Array(_len), _key = 0; _key < _len; _key++) {
    arrs[_key] = arguments[_key];
  }

  return arrs[0].map(function (_, i) {
    return arrs.map(function (arr) {
      return arr[i];
    });
  });
};

var SIDES = {
  'U': ['U', 'UBR', 'UR', 'URF', 'UF', 'UFL', 'UL', 'ULB', 'UB'],
  'F': ['F', 'FUR', 'FR', 'FRD', 'FD', 'FDL', 'FL', 'FLU', 'FU'],
  'D': ['D', 'DFR', 'DR', 'DRB', 'DB', 'DBL', 'DL', 'DLF', 'DF'],
  'B': ['B', 'BUL', 'BL', 'BLD', 'BD', 'BDR', 'BR', 'BRU', 'BU'],
  'R': ['R', 'RUB', 'RB', 'RBD', 'RD', 'RDF', 'RF', 'RFU', 'RU'],
  'L': ['L', 'LUF', 'LF', 'LFD', 'LD', 'LDB', 'LB', 'LBU', 'LU']
};
var LINES = {
  'R': ['URF', 'UR', 'UBR', 'BRU', 'BR', 'BDR', 'DRB', 'DR', 'DFR', 'FRD', 'FR', 'FUR'],
  'L': ['ULB', 'UL', 'UFL', 'FLU', 'FL', 'FDL', 'DLF', 'DL', 'DBL', 'BLD', 'BL', 'BUL'],
  'U': ['FUR', 'FU', 'FLU', 'LUF', 'LU', 'LBU', 'BUL', 'BU', 'BRU', 'RUB', 'RU', 'RFU'],
  'D': ['FDL', 'FD', 'FRD', 'RDF', 'RD', 'RBD', 'BDR', 'BD', 'BLD', 'LDB', 'LD', 'LFD'],
  'F': ['UFL', 'UF', 'URF', 'RFU', 'RF', 'RDF', 'DFR', 'DF', 'DLF', 'LFD', 'LF', 'LUF'],
  'B': ['UBR', 'UB', 'ULB', 'LBU', 'LB', 'LDB', 'DBL', 'DB', 'DRB', 'RBD', 'RB', 'RUB'],
  'M': ['UB', 'U', 'UF', 'FU', 'F', 'FD', 'DF', 'D', 'DB', 'BD', 'B', 'BU'],
  'S': ['UL', 'U', 'UR', 'RU', 'R', 'RD', 'DR', 'D', 'DL', 'LD', 'L', 'LU'],
  'E': ['FL', 'F', 'FR', 'RF', 'R', 'RB', 'BR', 'B', 'BL', 'LB', 'L', 'LF']
};
var PARTIAL_MOVES = {
  'r': ['R', "M'"],
  'l': ['L', 'M'],
  'u': ['U', "E'"],
  'd': ['D', 'E'],
  'f': ['F', 'S'],
  'b': ['B', "S'"],
  'y': ['u', "D'"],
  'z': ['f', "B'"],
  'x': ['r', "L'"],
  'Rw': ['r'],
  'Lw': ['l'],
  'Uw': ['u'],
  'Dw': ['d'],
  'Fw': ['f'],
  'Bw': ['b']
};
var newCube = function newCube() {
  return fromPairs(flatMap(Object.entries(SIDES), function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        side = _ref2[0],
        stickers = _ref2[1];

    return stickers.map(function (sticker) {
      return [sticker, side];
    });
  }));
};

var rotateStickers = function rotateStickers(cube, stickers, offset) {
  var values = stickers.map(function (sticker) {
    return cube[sticker];
  });
  var rotatedValues = rotate(values, -offset);
  /* Rotate clockwise for positive offsets. */

  return _objectSpread({}, cube, fromPairs(zip(stickers, rotatedValues)));
};

var rotateLine = function rotateLine(cube, line, amount) {
  return rotateStickers(cube, LINES[line], amount * 3);
};
var rotateSide = function rotateSide(cube, side, amount) {
  return rotateStickers(cube, SIDES[side].slice(1), amount * 2);
};
var applyMove = function applyMove(cube, move) {
  var _move$match = move.match(/^(.+?)(2?)('?)$/),
      _move$match2 = _slicedToArray(_move$match, 4),
      baseMove = _move$match2[1],
      double = _move$match2[2],
      anticlockwise = _move$match2[3];

  var amount = double ? 2 : anticlockwise ? -1 : 1;

  if (baseMove.match(/^[RLUDFB]$/)) {
    return rotateSide(rotateLine(cube, baseMove, amount), baseMove, amount);
  } else if (baseMove.match(/^[MSE]$/)) {
    return rotateLine(cube, baseMove, amount);
  } else if (PARTIAL_MOVES[baseMove]) {
    return applyMoves(cube, PARTIAL_MOVES[baseMove].map(function (partialMove) {
      return double ? doubleMove(partialMove) : anticlockwise ? invertMove(partialMove) : partialMove;
    }));
  } else {
    throw new Error("Invalid move: ".concat(move));
  }
};
var applyMoves = function applyMoves(cube, moves) {
  return moves.reduce(function (cube, move) {
    return applyMove(cube, move);
  }, cube);
};

var OPPOSITE_SIDE = {
  'U': 'D',
  'D': 'U',
  'R': 'L',
  'L': 'R',
  'F': 'B',
  'B': 'F'
};

var stickerSide = function stickerSide(sticker) {
  return sticker[0];
};
/* A sticker is considered solved when it has the same value as the corresponding center. */


var isStickerSolved = function isStickerSolved(cube, sticker) {
  return cube[sticker] === cube[stickerSide(sticker)];
};

var isSolved = function isSolved(cube) {
  return Object.keys(cube).every(function (sticker) {
    return isStickerSolved(cube, sticker);
  });
};

var isEdgeSticker = function isEdgeSticker(sticker) {
  return sticker.length === 2;
};

var isCornerSticker = function isCornerSticker(sticker) {
  return sticker.length === 3;
};

var elementStickers = function elementStickers(element) {
  return Array.from({
    length: element.length
  }, function (_, i) {
    return rotate(element.split(''), i).join('');
  });
};
/* An element is considered solved when all its stickers are solved.
   E.g. URF corner is solved when URF, RFU and FUR stickers are solved.
        UF edge is solved when UF and FU stickers are solved. */


var isElementSolved = function isElementSolved(cube, element) {
  return elementStickers(element).every(function (sticker) {
    return isStickerSolved(cube, sticker);
  });
};

var sameValue = function sameValue(cube, stickers) {
  return stickers.length === 0 || new Set(stickers.map(function (sticker) {
    return cube[sticker];
  })).size === 1;
};

var sameValueBySide = function sameValueBySide(cube, stickers) {
  return Object.values(SIDES).every(function (sideStickers) {
    return sameValue(cube, intersection(sideStickers, stickers));
  });
};
/* See: https://www.speedsolving.com/wiki/index.php/EOLine#EO_Detection */


var edgesOriented = function edgesOriented(cube) {
  var dSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'D';
  var fSide = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'F';
  var rSide = SIDES[dSide].filter(isCornerSticker).find(function (sticker) {
    return sticker.startsWith(dSide + fSide);
  })[2];

  var _map = [dSide, fSide, rSide].map(function (side) {
    return OPPOSITE_SIDE[side];
  }),
      _map2 = _slicedToArray(_map, 3),
      uSide = _map2[0],
      bSide = _map2[1],
      lSide = _map2[2];

  var stickers = [].concat(_toConsumableArray(SIDES[uSide]), _toConsumableArray(SIDES[dSide]), _toConsumableArray(LINES[rSide]), _toConsumableArray(LINES[lSide])).filter(isEdgeSticker);

  var value = function value(sticker) {
    return cube[sticker];
  };

  var hasSameValueAs = function hasSameValueAs(stickers, sticker) {
    return stickers.map(value).includes(value(sticker));
  };

  var anyMisoriented = stickers.some(function (sticker) {
    return hasSameValueAs([lSide, rSide], sticker) || hasSameValueAs([fSide, bSide], sticker) && hasSameValueAs([uSide, dSide], reverse(sticker));
  });
  return !anyMisoriented;
};
/* CFOP-specific */

var sidesWithCrossSolved = function sidesWithCrossSolved(cube) {
  return Object.entries(SIDES).filter(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        side = _ref2[0],
        stickers = _ref2[1];

    return stickers.filter(isEdgeSticker).every(function (sticker) {
      return isElementSolved(cube, sticker);
    });
  }).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        side = _ref4[0],
        stickers = _ref4[1];

    return side;
  });
};

var solvedSlots = function solvedSlots(cube) {
  var solvedSlotsWithSide = sidesWithCrossSolved(cube).map(function (side) {
    var solvedSlotsAroundCross = SIDES[side].filter(function (sticker) {
      return isCornerSticker(sticker) && isElementSolved(cube, sticker) && isElementSolved(cube, sticker.slice(1)
      /* Adjacent edge. */
      );
    });
    return {
      side: side,
      count: solvedSlotsAroundCross.length
    };
  });
  return solvedSlotsWithSide.length > 0 ? maxBy(solvedSlotsWithSide, function (_ref5) {
    var count = _ref5.count;
    return count;
  }) : {
    side: null,
    count: 0
  };
};
var crossBottomEdgesOriented = function crossBottomEdgesOriented(cube, crossSide) {
  var _SIDES$crossSide$find = SIDES[crossSide].find(isCornerSticker),
      _SIDES$crossSide$find2 = _toArray(_SIDES$crossSide$find),
      perpendicularSides = _SIDES$crossSide$find2.slice(1);

  return perpendicularSides.some(function (side) {
    return edgesOriented(cube, crossSide, side);
  });
};
var sideOriented = function sideOriented(cube, side) {
  var stickerPredicate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
    return true;
  };
  return sameValue(cube, SIDES[side].filter(stickerPredicate));
};
var sideEdgesOriented = function sideEdgesOriented(cube, side) {
  return sideOriented(cube, side, isEdgeSticker);
};
var sideCornersOriented = function sideCornersOriented(cube, side) {
  return sideOriented(cube, side, isCornerSticker);
};
var sideSolved = function sideSolved(cube, side) {
  var stickerPredicate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
    return true;
  };
  return [0, -1, 1, 2].map(function (n) {
    return rotateLine(cube, side, n);
  }).some(function (cube) {
    return SIDES[side].filter(stickerPredicate).every(function (sticker) {
      return isElementSolved(cube, sticker);
    });
  });
};
var sideCornersSolved = function sideCornersSolved(cube, side) {
  return sideSolved(cube, side, isCornerSticker);
};
/* Roux-specific */

var lrSquares = function lrSquares(cube) {
  return ['L', 'R'].map(function (side) {
    return SIDES[side].filter(isCornerSticker).filter(function (cornerSticker) {
      var adjacentEdges = cornerSticker.split('').slice(1).map(function (adjacentSide) {
        return "".concat(side).concat(adjacentSide);
      });
      var stickers = flatMap([].concat(_toConsumableArray(adjacentEdges), [cornerSticker, side]), elementStickers);
      return sameValueBySide(cube, stickers);
    });
  });
};
var ulurSolved = function ulurSolved(cube) {
  return ['R', 'L'].every(function (center) {
    return ['R', 'L', 'F', 'B'].some(function (side) {
      return intersection(SIDES[side], LINES['U']).every(function (sticker) {
        return cube[sticker] === cube[center];
      });
    });
  });
};
var uCornersSolved = function uCornersSolved(cube) {
  return sameValueBySide(cube, flatMap(SIDES['U'].filter(isCornerSticker), elementStickers));
};
/* ZZ-specific */

var eoLine = function eoLine(cube) {
  return isElementSolved(cube, 'DF') && isElementSolved(cube, 'DB') && edgesOriented(cube);
};
var lrF2lSquares = function lrF2lSquares(cube) {
  return lrSquares(cube).map(function (squares) {
    return squares.filter(function (corner) {
      return elementStickers(corner).some(function (sticker) {
        return cube[sticker] === cube['D'];
      });
    });
  });
};

var labelCFOPStep = function labelCFOPStep(previous, current) {
  var _solvedSlots = solvedSlots(previous),
      slotsPrevious = _solvedSlots.count,
      crossSidePrevious = _solvedSlots.side;

  var _solvedSlots2 = solvedSlots(current),
      slots = _solvedSlots2.count,
      crossSide = _solvedSlots2.side;

  if (!crossSidePrevious) {
    if (crossSide) return 'x'.repeat(slots) + 'cross';
  } else {
    var llSidePrevious = OPPOSITE_SIDE[crossSidePrevious];
    /* Current LL side is the one that has the value of previous LL side. */

    var llSide = Object.keys(OPPOSITE_SIDE).find(function (side) {
      return current[side] === previous[llSidePrevious];
    });

    if (slots > slotsPrevious) {
      var pairsLabel = ['1st', '2nd', '3rd', '4th'].slice(slotsPrevious, slots).join(' + ') + ' pair';

      if (slots === 4) {
        var label = function label(lastSlotLabel) {
          return "".concat(pairsLabel, " / ").concat(lastSlotLabel);
        };

        if (sideOriented(current, llSide)) return label(sideEdgesOriented(previous, llSidePrevious) ? 'CLS' : 'OLS');
        if (!crossBottomEdgesOriented(previous, crossSide) && sideEdgesOriented(current, llSide)) return label('EOLS');
      }

      return pairsLabel;
    } else if (slotsPrevious === 3 && slots === 3) {
      if (!sideEdgesOriented(previous, llSidePrevious) && sideEdgesOriented(current, llSide)) return 'ELS';
    } else if (slotsPrevious === 4 && slots === 4) {
      if (!sideEdgesOriented(previous, llSidePrevious)) {
        if (sideSolved(current, llSide)) return '1LLL';
        if (sideCornersSolved(current, llSide)) return 'OLLCP';
        if (sideOriented(current, llSide)) return 'OLL';
        if (sideEdgesOriented(current, llSide)) return 'EOLL';
      } else if (!sideOriented(previous, llSidePrevious)) {
        if (sideSolved(current, llSide)) return 'ZBLL';
        if (sideCornersSolved(current, llSide)) return 'COLL';
        if (sideOriented(current, llSide)) return 'OCLL';
      } else if (!sideCornersSolved(previous, llSidePrevious)) {
        if (sideSolved(current, llSide)) return 'PLL';
        if (sideCornersSolved(current, llSide)) return 'CPLL';
      } else if (!sideSolved(previous, llSidePrevious)) {
        if (sideSolved(current, llSide)) return 'EPLL';
      } else if (!isSolved(previous) && isSolved(current)) {
        return 'AUF';
      }
    }
  }
};

var dBlock = function dBlock(squares) {
  return squares.filter(function (cornerSticker) {
    return cornerSticker.includes('D');
  }).length === 2;
};

var labelRouxStep = function labelRouxStep(previous, current) {
  var _lrSquares = lrSquares(previous),
      _lrSquares2 = _slicedToArray(_lrSquares, 2),
      leftSquaresPrevious = _lrSquares2[0],
      rightSquaresPrevious = _lrSquares2[1];

  var _lrSquares3 = lrSquares(current),
      _lrSquares4 = _slicedToArray(_lrSquares3, 2),
      leftSquares = _lrSquares4[0],
      rightSquares = _lrSquares4[1];

  if (!dBlock(leftSquaresPrevious) && dBlock(leftSquares)) return 'LBlock';
  if (!dBlock(rightSquaresPrevious) && dBlock(rightSquares)) return 'RBlock';
  if (!leftSquaresPrevious.length && leftSquares.length) return 'LSquare';
  if (!rightSquaresPrevious.length && rightSquares.length) return 'RSquare';

  if (dBlock(leftSquares) && dBlock(rightSquares)) {
    if (!uCornersSolved(previous)) {
      if (uCornersSolved(current)) return !edgesOriented(previous) && edgesOriented(current) ? 'CMLL + EO' : 'CMLL';
    } else if (!edgesOriented(previous)) {
      if (edgesOriented(current)) return ulurSolved(current) ? 'EO + UL/UR' : 'EO';
    } else if (!ulurSolved(previous)) {
      if (isSolved(current)) return 'LSE';
      /* One move off solved state means that LSE is about to be done, so don't label as UL/UR. */

      if (!sideSolved(current, 'U') && edgesOriented(current) && ulurSolved(current)) return 'UL/UR';
    } else if (!isSolved(previous) && isSolved(current)) {
      return 'EP';
    }
  }
};
var labelZZStep = function labelZZStep(previous, current) {
  if (!eoLine(previous)) {
    if (eoLine(current)) return 'EOLine';
  } else {
    var _lrF2lSquares = lrF2lSquares(previous),
        _lrF2lSquares2 = _slicedToArray(_lrF2lSquares, 2),
        leftSquaresPrevious = _lrF2lSquares2[0],
        rightSquaresPrevious = _lrF2lSquares2[1];

    var _lrF2lSquares3 = lrF2lSquares(current),
        _lrF2lSquares4 = _slicedToArray(_lrF2lSquares3, 2),
        leftSquares = _lrF2lSquares4[0],
        rightSquares = _lrF2lSquares4[1];

    if (!dBlock(leftSquaresPrevious) && dBlock(leftSquares)) return 'LBlock';
    if (!dBlock(rightSquaresPrevious) && dBlock(rightSquares)) return 'RBlock';
    if (!leftSquaresPrevious.length && leftSquares.length) return 'LSquare';
    if (!rightSquaresPrevious.length && rightSquares.length) return 'RSquare';

    if (dBlock(leftSquares) && dBlock(rightSquares)) {
      if (!sideCornersOriented(previous, 'U')) {
        if (sideSolved(current, 'U')) return 'ZBLL';
        if (sideCornersSolved(current, 'U')) return 'COLL';
        if (sideCornersOriented(current, 'U')) return 'OCLL';
      } else if (!sideCornersSolved(previous, 'U')) {
        if (sideSolved(current, 'U')) return 'PLL';
        if (sideCornersSolved(current, 'U')) return 'CPLL';
      } else if (!sideSolved(previous, 'U')) {
        if (sideSolved(current, 'U')) return 'EPLL';
      } else if (!isSolved(previous) && isSolved(current)) {
        return 'AUF';
      }
    }
  }
};

var analyzeSolutionWith = function analyzeSolutionWith(scramble, solution, labelStep) {
  var _splitWith = splitWith(stringToMoves(solution), function (move) {
    return !move.match(/[xyz]/);
  }),
      _splitWith2 = _slicedToArray(_splitWith, 2),
      inspectionMoves = _splitWith2[0],
      solutionMoves = _splitWith2[1];

  var scrambledCube = applyMoves(newCube(), stringToMoves(scramble).concat(inspectionMoves));
  var preSolutionSteps = inspectionMoves.length > 0 ? [{
    label: 'inspection',
    moves: inspectionMoves
  }] : [];

  var _solutionMoves$reduce = solutionMoves.reduce(function (_ref, move) {
    var _ref2 = _slicedToArray(_ref, 4),
        steps = _ref2[0],
        previousStepCube = _ref2[1],
        cube = _ref2[2],
        stepMoves = _ref2[3];

    var cubeAfterMove = applyMove(cube, move);
    var label = labelStep(previousStepCube, cubeAfterMove);
    return label ? [[].concat(_toConsumableArray(steps), [{
      label: label,
      moves: [].concat(_toConsumableArray(stepMoves), [move])
    }]), cubeAfterMove, cubeAfterMove, []] : [steps, previousStepCube, cubeAfterMove, [].concat(_toConsumableArray(stepMoves), [move])];
  }, [preSolutionSteps, scrambledCube, scrambledCube, []]),
      _solutionMoves$reduce2 = _slicedToArray(_solutionMoves$reduce, 4),
      steps = _solutionMoves$reduce2[0],
      cube = _solutionMoves$reduce2[2],
      remainingMoves = _solutionMoves$reduce2[3];

  return {
    steps: remainingMoves.length > 0 ? [].concat(_toConsumableArray(steps), [{
      label: null,
      moves: remainingMoves
    }]) : steps,
    solved: isSolved(cube)
  };
};

var analyzeSolution = function analyzeSolution(scramble, solution, method) {
  if (!method) {
    throw new TypeError('Method is missing.');
  }

  switch (method.toLowerCase()) {
    case 'cfop':
      return analyzeSolutionWith(scramble, solution, labelCFOPStep);

    case 'roux':
      return analyzeSolutionWith(scramble, solution, labelRouxStep);

    case 'zz':
      return analyzeSolutionWith(scramble, solution, labelZZStep);

    default:
      throw new Error("Unsupported method '".concat(method, "'. Supported methods are: CFOP, Roux, ZZ."));
  }
};

export { analyzeSolution };
