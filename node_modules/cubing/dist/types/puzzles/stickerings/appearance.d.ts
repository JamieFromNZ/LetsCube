import type { Move } from "../../alg";
import type { KPuzzle } from "../../kpuzzle";
export declare type FaceletMeshAppearance = "regular" | "dim" | "oriented" | "ignored" | "invisible";
export declare type FaceletAppearance = {
    appearance: FaceletMeshAppearance;
    hintAppearance?: FaceletMeshAppearance;
};
export declare type PieceAppearance = {
    facelets: (FaceletMeshAppearance | FaceletAppearance | null)[];
};
export declare type OrbitAppearance = {
    pieces: (PieceAppearance | null)[];
};
export declare type PuzzleAppearance = {
    name?: string;
    orbits: Record<string, OrbitAppearance>;
};
export declare function getFaceletAppearance(appearance: PuzzleAppearance, orbitName: string, pieceIdx: number, faceletIdx: number, hint: boolean): FaceletMeshAppearance;
export declare enum PieceStickering {
    Regular = "Regular",
    Dim = "Dim",
    Ignored = "Ignored",
    OrientationStickers = "OrientationStickers",
    Invisible = "Invisible",
    Ignoriented = "Ignoriented",
    IgnoreNonPrimary = "IgnoreNonPrimary",
    PermuteNonPrimary = "PermuteNonPrimary",
    OrientationWithoutPermutation = "OrientationWithoutPermutation"
}
export declare class PieceAnnotation<T> {
    stickerings: Map<string, T[]>;
    constructor(kpuzzle: KPuzzle, defaultValue: T);
}
export declare function getPieceAppearance(pieceStickering: PieceStickering): PieceAppearance;
export declare class PuzzleStickering extends PieceAnnotation<PieceStickering> {
    constructor(kpuzzle: KPuzzle);
    set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering;
    toAppearance(): PuzzleAppearance;
}
export declare type PieceSet = PieceAnnotation<boolean>;
export declare class StickeringManager {
    private kpuzzle;
    constructor(kpuzzle: KPuzzle);
    and(pieceSets: PieceSet[]): PieceSet;
    or(pieceSets: PieceSet[]): PieceSet;
    not(pieceSet: PieceSet): PieceSet;
    all(): PieceSet;
    move(moveSource: Move | string): PieceSet;
    moves(moveSources: (Move | string)[]): PieceSet[];
}
