import { Move } from "../alg";
import type { KPuzzleDefinition, KTransformationData } from "../kpuzzle";
import { NotationMapper } from "./notation-mapping";
import { PuzzleGeometryOptions } from "./Options";
import { Perm } from "./Perm";
import { PGOrbitsDef, PGTransform } from "./PermOriSet";
import { PuzzleDescriptionString, PuzzleName } from "./PGPuzzles";
import { Quat } from "./Quat";
export interface TextureMapper {
    getuv(fn: number, threed: number[]): number[];
}
export interface StickerDatSticker {
    coords: number[];
    color: string;
    orbit: string;
    ord: number;
    ori: number;
    face: number;
    isDup?: boolean;
}
export interface StickerDatFace {
    coords: number[];
    name: string;
}
export declare type StickerDatAxis = {
    coordinates: number[];
    quantumMove: Move;
    order: number;
};
export interface StickerDat {
    stickers: StickerDatSticker[];
    faces: StickerDatFace[];
    axis: StickerDatAxis[];
    unswizzle(mv: Move): Move | null;
    notationMapper: NotationMapper;
    textureMapper: TextureMapper;
}
declare class Face {
    private coords;
    length: number;
    constructor(q: Quat[]);
    get(off: number): Quat;
    centermass(): Quat;
    rotate(q: Quat): Face;
    rotateforward(): Face;
}
export declare class FaceTree {
    private face;
    private left?;
    private right?;
    constructor(face: Quat[], left?: FaceTree | undefined, right?: FaceTree | undefined);
    split(q: Quat): FaceTree;
    collect(arr: Face[], leftfirst: boolean): Face[];
}
export declare function expandfaces(rots: Quat[], faces: Face[]): Face[];
export declare function getPG3DNamedPuzzles(): {
    [s: string]: PuzzleDescriptionString;
};
export declare function getPuzzleDescriptionString(puzzleName: PuzzleName): PuzzleDescriptionString;
export declare type CutDescription = {
    cutType: string;
    distance: number;
};
export declare type PuzzleDescription = {
    shape: string;
    cuts: CutDescription[];
};
export declare function parsePuzzleDescription(s: PuzzleDescriptionString): PuzzleDescription | null;
export declare function getPuzzleGeometryByDesc(desc: string, options?: PuzzleGeometryOptions): PuzzleGeometry;
export declare function getPuzzleGeometryByName(puzzleName: PuzzleName, options?: PuzzleGeometryOptions): PuzzleGeometry;
export declare class PuzzleGeometry {
    private puzzleDescription;
    private rotations;
    baseplanerot: Quat[];
    private baseplanes;
    private facenames;
    private faceplanes;
    private edgenames;
    private vertexnames;
    private geonormals;
    private moveplanes;
    private moveplanes2;
    moveplanesets: Quat[][];
    private moveplanenormals;
    movesetorders: number[];
    movesetgeos: [string, string, string, string, number][];
    private basefaces;
    private faces;
    private facecentermass;
    private baseFaceCount;
    stickersperface: number;
    shortedge: number;
    cubies: number[][];
    private vertexdistance;
    private edgedistance;
    private facetocubie;
    private facetoord;
    private moverotations;
    private facelisthash;
    private cubiesetnames;
    private cubieords;
    private cubiesetnums;
    private cubieordnums;
    private orbitoris;
    private cubievaluemap;
    private cubiesetcubies;
    cmovesbyslice: number[][][];
    parsedmovelist: [
        string | undefined,
        number,
        number,
        number,
        boolean,
        number
    ][];
    private duplicatedFaces;
    private duplicatedCubies;
    private fixedCubie;
    private net;
    private colors;
    private faceorder;
    private faceprecedence;
    private swizzler;
    notationMapper: NotationMapper;
    private addNotationMapper;
    private setReidOrder;
    private options;
    constructor(puzzleDescription: PuzzleDescription, options: PuzzleGeometryOptions);
    create(puzzleDescription: PuzzleDescription): void;
    private keyface;
    private keyface2;
    private keyface3;
    private findface;
    private project2d;
    allstickers(): void;
    unswizzle(mv: Move): Move | null;
    private stringToBlockMove;
    parseMove(move: Move): [string | undefined, number, number, number, boolean, number];
    private parsemove;
    genperms(): void;
    private getboundarygeometry;
    private getmovesets;
    private graybyori;
    private skipbyori;
    private skipcubie;
    private header;
    writegap(): string;
    writeksolve(name?: string): string;
    getKPuzzleDefinition(fortwisty?: boolean, includemoves?: boolean): KPuzzleDefinition;
    getMoveFromBits(moverange: number[], amount: number, inverted: boolean, axiscmoves: number[][], setmoves: number[] | undefined, movesetorder: number): PGTransform;
    private omitSet;
    private diffmvsets;
    getOrbitsDef(fortwisty: boolean, includemoves?: boolean): PGOrbitsDef;
    getScramble(n?: number): KTransformationData;
    getMovesAsPerms(): Perm[];
    showcanon(disp: (s: string) => void): void;
    getsolved(): Perm;
    private getOrientationRotation;
    private getInitial3DRotation;
    private generate2dmapping;
    generatesvg(w?: number, h?: number, trim?: number, threed?: boolean): string;
    get3d(options?: {
        stickerColors?: string[];
    }): StickerDat;
    getGeoNormal(geoname: string): number[] | undefined;
    private getfaceindex;
    textForTwizzleExplorer(): string;
    writeSchreierSims(tw: (s: string) => void): void;
}
export declare class PGNotation {
    private pg;
    private orbitNames;
    constructor(pg: PuzzleGeometry, od: PGOrbitsDef);
    lookupMove(move: Move): KTransformationData | null;
}
export {};
