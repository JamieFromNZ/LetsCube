import type { KPuzzleDefinition, KTransformationData } from "../kpuzzle";
import type { NotationMapper } from "./notation-mapping/NotationMapper";
import { Perm } from "./Perm";
export declare class PGOrbitDef {
    size: number;
    mod: number;
    constructor(size: number, mod: number);
    reassemblySize(): number;
}
export declare function externalName(mapper: NotationMapper, moveString: string): string;
export declare class PGOrbitsDef {
    orbitnames: string[];
    private orbitdefs;
    solved: VisibleState;
    movenames: string[];
    moveops: PGTransform[];
    constructor(orbitnames: string[], orbitdefs: PGOrbitDef[], solved: VisibleState, movenames: string[], moveops: PGTransform[]);
    transformToKTransformationData(t: PGTransform): KTransformationData;
    static transformToKTransformationData(orbitnames: string[], t: PGTransform): KTransformationData;
    toKsolve(name: string, mapper?: NotationMapper): string[];
    toKPuzzleDefinition(includemoves: boolean): KPuzzleDefinition;
    optimize(): PGOrbitsDef;
    scramble(n: number): void;
    getScrambleTransformation(n: number): PGTransform;
    reassemblySize(): number;
}
export declare class PGOrbit {
    perm: number[];
    ori: number[];
    orimod: number;
    private static kcache;
    static e(n: number, mod: number): PGOrbit;
    constructor(perm: number[], ori: number[], orimod: number);
    mul(b: PGOrbit): PGOrbit;
    inv(): PGOrbit;
    equal(b: PGOrbit): boolean;
    killOri(): this;
    toPerm(): Perm;
    identicalPieces(): number[][];
    order(): number;
    isIdentity(): boolean;
    private zeroOris;
    remap(no: number[], on: number[], nv: number): PGOrbit;
    remapVS(no: number[], nv: number): PGOrbit;
    appendDefinition(result: string[], name: string, useVS: boolean, concise?: boolean): void;
    toKPuzzle(): Record<string, number[]>;
}
export declare class PGTransformBase {
    orbits: PGOrbit[];
    constructor(orbits: PGOrbit[]);
    internalMul(b: PGTransformBase): PGOrbit[];
    protected internalInv(): PGOrbit[];
    equal(b: PGTransformBase): boolean;
    protected killOri(): this;
    toPerm(): Perm;
    identicalPieces(): number[][];
    order(): number;
}
export declare class PGTransform extends PGTransformBase {
    constructor(orbits: PGOrbit[]);
    mul(b: PGTransform): PGTransform;
    mulScalar(n: number): PGTransform;
    inv(): PGTransform;
    e(): PGTransform;
}
export declare class VisibleState extends PGTransformBase {
    constructor(orbits: PGOrbit[]);
    mul(b: PGTransform): VisibleState;
}
export declare function showcanon(g: PGOrbitsDef, disp: (s: string) => void): void;
export declare function showcanon0(g: PGOrbitsDef, disp: (s: string) => void): void;
