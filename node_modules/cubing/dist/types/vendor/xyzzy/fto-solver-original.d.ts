declare function counter(A: any): any[];
declare function factorial(n: any): any;
declare function C(n: any, k: any): number;
declare function C4(n: any, k0: any, k1: any, k2: any, k3?: number): number;
declare function permutation_to_index(perm: any): number;
declare function index_to_permutation(ind: any, n: any): number[];
declare function permutation_parity(A: any): number;
declare function index_to_evenpermutation(ind: any, n: any): number[];
declare function evenpermutation_to_index(perm: any): number;
declare function random_permutation(n: any): number[];
declare function random_even_permutation(n: any): number[];
declare function comb_to_index(l: any): number;
declare function index_to_comb(ind: any, ones: any, bits: any): any[];
declare function ctz(n: any): number;
declare function generate_comb_lookup_tables(n: any, k: any): any;
declare function popcount(n: any): number;
declare function spread_bits(n: any): any;
declare function interleave_bits(x: any, y: any): number;
declare function generate_comb4_lookup_tables(n: any, k0: any, k1: any, k2: any, k3: any): any;
declare function compose(A: any, B: any): any[];
declare function compose3(A: any, B: any, C: any): any[];
declare function compose_o(A: any, B: any): any[][];
declare function permutation_from_cycles(cycles: any, n: any): any[];
declare function reduce_permutation(perm: any, keep: any): any[];
declare function invert_permutation(perm: any): any[];
declare function gcd(a: any, b: any): number;
declare function lcm(a: any, b: any): number;
declare function permutation_order(perm: any): number;
declare function identify_corner_piece(colourA: any, colourB: any): number[];
declare function identify_edge_piece(colourA: any, colourB: any): number;
declare function get_corner_piece(facelets: any, location: any): number[];
declare function get_edge_piece(facelets: any, location: any): number;
declare function set_corner_piece(facelets: any, location: any, value: any, orientation: any): void;
declare function set_edge_piece(facelets: any, location: any, value: any): void;
declare function convert_move_to_permutations(move: any): {
    cp: number[];
    ep: number[];
    ap: number[];
    bp: number[];
};
declare function random_state(): any[];
declare function stringify_move_sequence(move_sequence: any, no_wide?: boolean): any;
declare function print_move_sequence(move_sequence: any): void;
declare function apply_move_sequence(state: any, move_sequence: any): any;
declare function invert_move_sequence(move_sequence: any): any;
declare function simplify_move_sequence(move_sequence: any, make_noise?: boolean): any[][];
declare function generate_random_state_scramble(): any;
declare function generate_multiple_random_state_scrambles(n: any): any[];
declare function generate_mtable_comb_generic(n: any, k: any, permutations: any): Uint32Array[];
declare function generate_mtable_comb4_generic(n: any, k0: any, k1: any, k2: any, k3: any, permutations: any): Uint32Array[];
declare function generate_mtable_single_generic(permutations: any): Uint32Array[];
declare function combine_mtables(mtable0: any, mtable1: any): Uint32Array[];
declare function trim_unreachable(mtable: any, origin: any): any[];
declare function reduce_to_quotient(mtable: any, origins: any): (Int32Array | Int32Array[])[];
declare function generate_mirrored_coordinate_table(mtable: any, a: any, b: any): Int32Array;
declare function bfs(mtable: any, goal_states: any): Int8Array;
declare function ida_solve_gen(indices: any, mtables: any, ptables: any, moves_left: any, commute: any): Generator<any, void, any>;
declare function ida_search_gen(indices: any, mtables: any, ptables: any, bound: any, last: any, commute: any): any;
declare function solve(facelets: any, readable?: boolean): any[][];
declare function index_phase1(facelets: any): any[];
declare function generate_phase1_edge_mtable(): any;
declare function generate_phase1_edge_ptable(): any;
declare function generate_phase1_centreA_mtable(): any;
declare function generate_phase1_centreB_mtable(): any;
declare function generate_phase1_centre_ptable(): any;
declare function solve_phase1_gen(facelets: any): Generator<any, void, any>;
declare function phase1_ida_solve_gen(indices: any, mtables: any, ptables: any, moves_left: any): Generator<any, void, any>;
declare function phase1_ida_search_gen(indices: any, mtables: any, ptables: any, bound: any, last: any): any;
declare function index_phase2(facelets: any): any[];
declare function solve_phase2_gen(facelets: any): Generator<any, void, any>;
declare function solve_phase2(facelets: any): any;
declare function generate_phase2_centre_mtables(): any;
declare function generate_phase2_edge_mtable(): any;
declare function generate_phase2_corner_mtable(): any;
declare function generate_phase2_corner_mtable_compact(): any;
declare function generate_phase2_ce_mtable(): any;
declare function generate_phase2_ce_mirror_map(): any;
declare function phase2_centre_goal_states(): any;
declare function phase2_corner_goal_states(): number[];
declare function generate_phase2_ace_ptable(): any;
declare function phase2_ida_solve_gen(indices: any, moves_left: any): Generator<any, void, any>;
declare function phase2_ida_search_gen(a: any, b: any, ce: any, mtable_a: any, mtable_b: any, mtable_ce: any, ptable_ace: any, mirror_map: any, bound: any, last: any): any;
declare function index_phase3_2gen(facelets: any): any[];
declare function generate_phase3_2gen_edge_mtable(): any;
declare function generate_phase3_2gen_corner_mtable(): any;
declare function generate_phase3_2gen_corneredge_mtable(): any;
declare function generate_phase3_2gen_centre_mtable(): any;
declare function generate_phase3_2gen_depth_table(): any;
declare function solve_phase3_2gen(facelets: any, indices?: any[], simplify?: boolean): any[];
declare function solve_phase3_2gen_readable(facelets: any, indices?: any[]): any[][] | undefined;
declare function alternation_penalty(x: any): number;
declare function grade_readability(seq: any): any;
declare function alternations(seq: any): number[];
declare function solve_phase3_2gen_ida(ab: any, ce: any, mtable_ab: any, mtable_ce: any, depth_table: any, bound: any, last?: number): any;
declare function solve_phase2_and_phase3_fast(facelets: any, phase2_attempts?: number, cap?: number): any;
declare function solve_phase2_and_phase3_readable(facelets: any, phase2_attempts?: number, cap?: number): any[][] | undefined;
declare function phase3_benchmark(solver?: typeof solve_phase3_2gen): void;
declare function solver_benchmark(solver?: typeof solve): void;
declare namespace rng {
    export { next };
    export const is_crypto: boolean;
}
declare function evenpermutation8_to_index(perm: any): number;
declare function index_to_evenpermutation8(ind: any, perm: any): any;
declare let comb_lookup_tables: {};
declare let comb4_lookup_tables: {};
declare let solved_state: number[];
declare let move_U: any[];
declare let move_Ui: any[];
declare let move_X: number[];
declare let move_Y: number[];
declare let move_Z: number[];
declare let move_Us: any[];
declare let move_Uw: any[];
declare let move_Uwi: any[];
declare let move_Lw: any[];
declare let move_Fw: any[];
declare let move_Rw: any[];
declare let colour_map: number[];
declare let corner_piece_facelets: number[][];
declare let edge_piece_facelets: number[][];
declare let centreA_piece_facelets: number[];
declare let centreB_piece_facelets: number[];
declare let move_permutations: any;
declare let cached_mtables: {};
declare let cached_ptables: {};
declare let phase1_centre_colour_map: number[];
declare let phase2_centre_colour_map: number[];
declare let phase2_centre_indices: number[];
declare let phase2_keep: boolean[];
declare let phase2_corner_keep: boolean[];
declare let phase2_edge_reduction_map: any;
declare let phase2_corner_reduction_map: any;
declare let phase2_ce_mirror_map: any;
declare let phase3_2gen_centre_indices: number[];
declare let phase3_2gen_keep: boolean[];
declare let phase3_2gen_move_seqs: number[][][];
declare let phase3_2gen_nmoves: number;
declare let phase3_2gen_facelet_permutations: any[];
declare let phase3_2gen_piece_permutations: {
    cp: number[];
    ep: number[];
    ap: number[];
    bp: number[];
}[];
declare let phase3_2gen_move_orders: number[];
declare let phase3_2gen_depth_table: any;
declare function next(bound: any): number | undefined;
