{
  "version": 3,
  "sources": ["../../src/cubing/search/inside/solve/puzzles/clock.ts", "../../src/cubing/search/inside/solve/puzzles/wca-minx.ts", "../../src/cubing/vendor/comlink-everywhere/outside/index.ts", "../../src/cubing/search/inside/search-worker-ts-entry-path-getter.ts", "../../src/cubing/search/instantiator.ts", "../../src/cubing/search/outside.ts"],
  "sourcesContent": ["import { randomUIntBelowFactory } from \"../../../../vendor/random-uint-below\";\n\nconst pins = [\"UR\", \"DR\", \"DL\", \"UL\"];\nconst backMoves = [\"U\", \"R\", \"D\", \"L\", \"ALL\"];\nconst frontMoves = pins.concat(backMoves);\n\nconst randomUIntBelowPromise = randomUIntBelowFactory();\n\nexport async function randomClockScrambleString(): Promise<string> {\n  const randomUIntBelow = await randomUIntBelowPromise;\n\n  let filteringMoveCount = 0;\n\n  async function randomSuffix(randomUIntBelow: (max: number) => number) {\n    const amount = randomUIntBelow(12);\n    if (amount !== 0) {\n      filteringMoveCount++;\n    }\n    if (amount <= 6) {\n      return `${amount}+`;\n    } else {\n      return `${12 - amount}-`;\n    }\n  }\n\n  const moves = [];\n  async function side(families: string[]): Promise<void> {\n    for (const family of families) {\n      moves.push(`${family}${await randomSuffix(randomUIntBelow)}`);\n    }\n  }\n\n  await side(frontMoves);\n  moves.push(\"y2\");\n  await side(backMoves);\n\n  // https://www.worldcubeassociation.org/regulations/#4b3\n  if (filteringMoveCount < 2) {\n    return randomClockScrambleString();\n  }\n\n  for (const pin of pins) {\n    if (randomUIntBelow(2) === 0) {\n      moves.push(pin);\n    }\n  }\n  return moves.join(\" \");\n}\n", "import { randomUIntBelowFactory } from \"../../../../vendor/random-uint-below\";\n\nconst randomUIntBelowPromise = randomUIntBelowFactory();\n\nconst suffixes = [\"++\", \"--\"];\n\nexport async function randomMegaminxScrambleString(): Promise<string> {\n  const randomUIntBelow = await randomUIntBelowPromise;\n\n  function rdPair(): string {\n    return `R${suffixes[randomUIntBelow(2)]} D${suffixes[randomUIntBelow(2)]}`;\n  }\n\n  function randomU(): string {\n    return `U${[\"\", \"'\"][randomUIntBelow(2)]}`;\n  }\n\n  function row(): string {\n    const chunks = [];\n    for (let i = 0; i < 5; i++) {\n      chunks.push(rdPair());\n    }\n    chunks.push(randomU());\n    return chunks.join(\" \");\n  }\n\n  const chunks = [];\n  for (let i = 0; i < 6; i++) {\n    chunks.push(row());\n  }\n  return chunks.join(\"\\n\");\n}\n", "import nodeEndpoint from \"../node-adapter\";\n\nexport { wrap } from \"comlink\";\n// Mangled so that bundlers don't try to inline the source.\n\nconst worker_threads_mangled = \"w-orker-_threa-ds\";\nconst worker_threads_unmangled = () => worker_threads_mangled.replace(/-/g, \"\");\n\nconst useNodeWorkarounds =\n  typeof globalThis.Worker === \"undefined\" &&\n  typeof (globalThis as any).WorkerNavigator === \"undefined\";\n\nasync function nodeWorker(\n  source: string | URL,\n  options?: { eval?: boolean },\n): Promise<Worker> {\n  const { Worker: NodeWorker } = await import(\n    /* @vite-ignore */ worker_threads_unmangled()\n  );\n  const worker = new NodeWorker(source, options);\n  worker.unref();\n  return nodeEndpoint(worker);\n}\n\nexport async function constructWorker(\n  source: string | URL,\n  options?: { eval?: boolean; type?: WorkerType },\n): Promise<Worker> {\n  let worker;\n  if (useNodeWorkarounds) {\n    return nodeWorker(source, { eval: options?.eval });\n  } else {\n    if (options?.eval) {\n      const blob = new Blob([source as string], {\n        type: \"application/javascript\",\n      });\n      source = URL.createObjectURL(blob);\n    }\n    worker = new globalThis.Worker(source, {\n      type: options ? options.type : undefined, // TODO: Is it safe to use `options?.type`?\n    });\n  }\n  return worker;\n}\n", "import { exposeAPI } from \"./worker-guard\";\n\nexposeAPI.expose = false;\nexport async function getWorkerEntryFileURL() {\n  return (await import(\"./search-worker-ts-entry\")).WORKER_ENTRY_FILE_URL;\n}\n", "import { constructWorker, wrap } from \"../vendor/comlink-everywhere/outside\";\nimport type { WorkerInsideAPI } from \"./inside/api\";\nimport { getWorkerEntryFileURL } from \"./inside/search-worker-ts-entry-path-getter\";\n\nconst MODULE_WORKER_TIMEOUT_MILLISECONDS = 5000;\n\nlet forceStringWorker: boolean = false;\nexport function setForceStringWorker(force: boolean): void {\n  forceStringWorker = force;\n}\n\nexport async function instantiateModuleWorker(): Promise<WorkerInsideAPI> {\n  // eslint-disable-next-line no-async-promise-executor\n  return new Promise<WorkerInsideAPI>(async (resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      reject(new Error(\"module instantiation timeout\"));\n    }, MODULE_WORKER_TIMEOUT_MILLISECONDS);\n\n    try {\n      const workerEntryFileURL = await getWorkerEntryFileURL();\n      if (!workerEntryFileURL) {\n        // This happens in `bundle-global`.\n        reject(new Error(\"Could not get worker entry file URL.\"));\n      }\n      let url: string | URL;\n      if (globalThis.Blob) {\n        // Standard browser-like environment.\n        const importSrc = `import \"${workerEntryFileURL}\";`;\n        const blob = new Blob([importSrc], {\n          type: \"text/javascript\",\n        });\n        url = URL.createObjectURL(blob);\n      } else {\n        // `node` doesn't have `Blob`. We can keep the original entry file URL there, but we have to wrap it.\n        // Needed for `node`\n        url = new URL(workerEntryFileURL);\n      }\n\n      const worker = (await constructWorker(url, {\n        type: \"module\",\n      })) as Worker & {\n        nodeWorker?: import(\"worker_threads\").Worker;\n      };\n\n      const onError = (e: ErrorEvent) => {\n        // TODO: Remove fallback when Firefox implements module workers: https://bugzilla.mozilla.org/show_bug.cgi?id=1247687\n        if (e.message?.startsWith(\"SyntaxError\")) {\n          reject(e);\n        }\n      };\n\n      const onFirstMessage = (messageData: string) => {\n        if (messageData === \"comlink-exposed\") {\n          // We need to clear the timeout so that we don't prevent `node` from exiting in the meantime.\n          clearTimeout(timeoutID);\n          resolve(wrap<WorkerInsideAPI>(worker));\n        } else {\n          reject(\n            new Error(\"wrong module instantiation message \" + messageData),\n          );\n        }\n      };\n\n      if (worker.nodeWorker) {\n        // We have to use `once` so the `unref()` from `comlink-everywhere` allows the process to quite as expected.\n        worker.nodeWorker.once(\"message\", onFirstMessage);\n      } else {\n        worker.addEventListener(\"error\", onError, {\n          once: true,\n        });\n        worker.addEventListener(\"message\", (e) => onFirstMessage(e.data), {\n          once: true,\n        });\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nasync function instantiateClassicWorker(): Promise<WorkerInsideAPI> {\n  const { workerSource } = await import(\"./worker-inside-generated-string.js\");\n  const worker = await constructWorker(workerSource, { eval: true });\n  return wrap(worker);\n}\n\nexport async function instantiateWorker(): Promise<WorkerInsideAPI> {\n  if (forceStringWorker) {\n    console.warn(\n      \"Using the `forceStringWorker` workaround for search worker instantiation. This will require downloading significantly more code than necessary, but the functionality will be the same.\",\n    );\n    return instantiateClassicWorker();\n  }\n  try {\n    // `await` is important for `catch` to work.\n    return await instantiateModuleWorker();\n  } catch (e) {\n    console.warn(\n      \"Could not instantiate module worker (this may happen in Firefox, with `bundle-global`, or when using Parcel). Falling back to string worker.\",\n      e,\n    );\n    return instantiateClassicWorker();\n  }\n}\n", "import { Alg } from \"../alg\";\n// import { preInitialize222 } from \"../implementations/2x2x2\";\nimport { randomClockScrambleString } from \"./inside/solve/puzzles/clock\"; // TODO: don't reach into `inside` code.\nimport { randomMegaminxScrambleString } from \"./inside/solve/puzzles/wca-minx\"; // TODO: don't reach into `inside` code.\nimport { instantiateWorker, setForceStringWorker } from \"./instantiator\";\nimport type { PrefetchLevel, WorkerInsideAPI } from \"./inside/api\";\nimport type { KState } from \"../kpuzzle/KState\";\n\nlet cachedWorkerInstance: Promise<WorkerInsideAPI> | null = null;\nasync function getCachedWorkerInstance(): Promise<WorkerInsideAPI> {\n  return await (cachedWorkerInstance ??= instantiateWorker());\n}\n\n// Pre-initialize the scrambler for the given event. (Otherwise, an event is\n// initialized the first time you ask for a scramble for that event.)\n//\n// Some typical numbers for a fast computer:\n// - 3x3x3 initialization: 200ms\n// - Each 3x3x3 scramble: 50ms\n// - 4x4x4 initialization: 2500ms\n// - Each 4x4x4 scramble: 300ms to 800ms\n//\n// It is safe to immediately call for a scramble\n// any time after starting pre-initialization, or to call for them without\n// pre-initializing. Pre-initializing essentially gives the scramble worker a\n// head start in case a scramble doesn't get requested immediately.\n//\n// Note that events cannot be pre-initialized in parallel. Attempting to\n// pre-initialize multiple events will initialize them consecutively. Scrambles\n// for a given event cannot be computed while another event is being initialized.\nexport function _preInitializationHintForEvent(\n  eventID: string,\n  // callback?: () => void\n): void {\n  switch (eventID) {\n    case \"clock\":\n    case \"minx\":\n      return;\n    case \"333oh\":\n      return _preInitializationHintForEvent(\"333\");\n  }\n  (async () => {\n    await (await getCachedWorkerInstance()).initialize(eventID);\n  })();\n}\n\nexport async function randomScrambleForEvent(eventID: string): Promise<Alg> {\n  switch (eventID) {\n    case \"clock\":\n      return Alg.fromString(await randomClockScrambleString());\n    case \"minx\":\n      return Alg.fromString(await randomMegaminxScrambleString());\n  }\n  const prom = _randomScrambleStringForEvent(eventID);\n  const wat = await prom;\n  return Alg.fromString(wat);\n}\n\nexport async function _randomScrambleStringForEvent(\n  eventID: string,\n): Promise<string> {\n  const cwi = await getCachedWorkerInstance();\n  return cwi.randomScrambleStringForEvent(eventID);\n}\n\nexport async function randomScrambleStringForEvent(\n  eventID: string,\n): Promise<string> {\n  switch (eventID) {\n    case \"clock\":\n      return randomClockScrambleString();\n    case \"minx\":\n      return randomMegaminxScrambleString();\n  }\n  return await _randomScrambleStringForEvent(eventID);\n}\n\nexport async function experimentalSolve3x3x3IgnoringCenters(\n  state: KState,\n): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solve333ToString(state.stateData));\n}\n\nexport async function experimentalSolve2x2x2(state: KState): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solve222ToString(state.stateData));\n}\n\nexport async function solveSkewb(state: KState): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solveSkewbToString(state.stateData));\n}\n\nexport async function solvePyraminx(state: KState): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solvePyraminxToString(state.stateData));\n}\n\nexport async function solveMegaminx(state: KState): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solveMegaminxToString(state.stateData));\n}\n\nexport function setDebug(options: {\n  logPerf?: boolean;\n  scramblePrefetchLevel?: `${PrefetchLevel}`;\n  forceStringWorker?: boolean;\n}): void {\n  const { logPerf, scramblePrefetchLevel } = options;\n  if (typeof logPerf !== \"undefined\") {\n    getCachedWorkerInstance().then((cwi) => cwi.setDebugMeasurePerf(logPerf));\n  }\n  if (typeof scramblePrefetchLevel !== \"undefined\") {\n    getCachedWorkerInstance().then((cwi) =>\n      cwi.setScramblePrefetchLevel(scramblePrefetchLevel as PrefetchLevel),\n    );\n  }\n  if (\"forceStringWorker\" in options) {\n    setForceStringWorker(!!options.forceStringWorker);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
