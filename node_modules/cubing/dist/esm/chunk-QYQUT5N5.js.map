{
  "version": 3,
  "sources": ["../../src/cubing/puzzles/customPGPuzzleLoader.ts", "../../src/cubing/puzzles/events.ts", "../../src/cubing/puzzles/stickerings/appearance.ts", "../../src/cubing/puzzles/stickerings/global-custom-stickering-hack.ts", "../../src/cubing/puzzles/stickerings/cube-stickerings.ts", "../../src/cubing/puzzles/async/lazy-cached.ts", "../../src/cubing/puzzles/async/async-pg3d.ts", "../../src/cubing/puzzles/implementations/2x2x2/index.ts", "../../src/cubing/puzzles/implementations/3x3x3/index.ts", "../../src/cubing/puzzles/implementations/clock/index.ts", "../../src/cubing/puzzles/stickerings/fto-stickerings.ts", "../../src/cubing/puzzles/implementations/fto/index.ts", "../../src/cubing/puzzles/stickerings/megaminx-stickerings.ts", "../../src/cubing/puzzles/implementations/megaminx/index.ts", "../../src/cubing/puzzles/implementations/pyraminx/index.ts", "../../src/cubing/puzzles/implementations/square1/index.ts", "../../src/cubing/puzzles/implementations/kilominx/index.ts", "../../src/cubing/puzzles/implementations/redi-cube/index.ts", "../../src/cubing/puzzles/index.ts"],
  "sourcesContent": ["import { KPuzzle, KPuzzleDefinition } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: dedup with `cubing/puzzles`\nexport async function asyncGetKPuzzle(\n  desc: PuzzleDescriptionString,\n): Promise<KPuzzle> {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: async () => {\n      return (cachedKPuzzle ??= asyncGetKPuzzle(desc));\n    },\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n", "import type { PuzzleID } from \"../twisty\";\n\ninterface EventInfo {\n  puzzleID: PuzzleID;\n  eventName: string;\n}\n\nconst wcaEvents: Record<string, EventInfo> = {\n  \"333\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Cube\" },\n  \"222\": { puzzleID: \"2x2x2\", eventName: \"2x2x2 Cube\" },\n  \"444\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Cube\" },\n  \"555\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Cube\" },\n  \"666\": { puzzleID: \"6x6x6\", eventName: \"6x6x6 Cube\" },\n  \"777\": { puzzleID: \"7x7x7\", eventName: \"7x7x7 Cube\" },\n  \"333bf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Blindfolded\" },\n  \"333fm\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Fewest Moves\" },\n  \"333oh\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 One-Handed\" },\n  \"clock\": { puzzleID: \"clock\", eventName: \"Clock\" },\n  \"minx\": { puzzleID: \"megaminx\", eventName: \"Megaminx\" },\n  \"pyram\": { puzzleID: \"pyraminx\", eventName: \"Pyraminx\" },\n  \"skewb\": { puzzleID: \"skewb\", eventName: \"Skewb\" },\n  \"sq1\": { puzzleID: \"square1\", eventName: \"Square-1\" },\n  \"444bf\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Blindfolded\" },\n  \"555bf\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Blindfolded\" },\n  \"333mb\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Multi-Blind\" },\n};\n\nexport function wcaEventInfo(event: string): EventInfo | null {\n  return wcaEvents[event] ?? null;\n}\n\nconst events: Record<string, EventInfo> = {\n  ...wcaEvents,\n  fto: { puzzleID: \"fto\", eventName: \"Face-Turning Octahedron\" },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\",\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\",\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\",\n  },\n};\n\nexport function eventInfo(event: string): EventInfo | null {\n  return events[event] ?? null;\n}\n", "// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshAppearance =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"ignored\"\n  | \"invisible\";\n\nexport type FaceletAppearance = {\n  appearance: FaceletMeshAppearance;\n  hintAppearance?: FaceletMeshAppearance;\n};\n\nexport type PieceAppearance = {\n  // TODO: foundation?\n  facelets: (FaceletMeshAppearance | FaceletAppearance | null)[];\n};\n\nexport type OrbitAppearance = {\n  pieces: (PieceAppearance | null)[];\n};\n\nexport type PuzzleAppearance = {\n  name?: string; // TODO\n  orbits: Record<string, OrbitAppearance>;\n};\n\nexport function getFaceletAppearance(\n  appearance: PuzzleAppearance,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshAppearance {\n  const orbitAppearance = appearance.orbits[orbitName];\n  const pieceAppearance: PieceAppearance | null =\n    orbitAppearance.pieces[pieceIdx];\n  if (pieceAppearance === null) {\n    return regular;\n  }\n  const faceletAppearance: FaceletMeshAppearance | FaceletAppearance | null =\n    pieceAppearance.facelets[faceletIdx];\n  if (faceletAppearance === null) {\n    return regular;\n  }\n  if (typeof faceletAppearance === \"string\") {\n    return faceletAppearance;\n  }\n  if (hint) {\n    return faceletAppearance.hintAppearance ?? faceletAppearance.appearance;\n  }\n  return faceletAppearance.appearance;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const [orbitName, orbitDef] of Object.entries(\n      kpuzzle.definition.orbits,\n    )) {\n      this.stickerings.set(\n        orbitName,\n        new Array(orbitDef.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\n\n// regular\nconst r: PieceAppearance = {\n  facelets: [regular, regular, regular, regular, regular],\n};\n\n// ignored\nconst i: PieceAppearance = {\n  facelets: [ignored, ignored, ignored, ignored, ignored],\n};\n\n// oriented stickers\nconst o: PieceAppearance = {\n  facelets: [oriented, oriented, oriented, oriented, oriented],\n};\n\n// invisible\nconst invisiblePiece: PieceAppearance = {\n  facelets: [invisible, invisible, invisible, invisible], // TODO: 4th entry is for void cube. Should be handled properly for all stickerings.\n};\n\n// \"OLL\"\nconst riiii: PieceAppearance = {\n  facelets: [regular, ignored, ignored, ignored, ignored],\n};\n\n// \"PLL\"\nconst drrrr: PieceAppearance = {\n  facelets: [dim, regular, regular, regular, regular],\n};\n\n// ignored\nconst d: PieceAppearance = {\n  facelets: [dim, dim, dim, dim, dim],\n};\n\n// \"OLL\"\nconst diiii: PieceAppearance = {\n  facelets: [dim, ignored, ignored, ignored, ignored],\n};\n\n// oriented\nconst oiiii: PieceAppearance = {\n  facelets: [oriented, ignored, ignored, ignored, ignored],\n};\n\nexport function getPieceAppearance(\n  pieceStickering: PieceStickering,\n): PieceAppearance {\n  switch (pieceStickering) {\n    case PieceStickering.Regular:\n      return r;\n    case PieceStickering.Dim:\n      return d;\n    case PieceStickering.Ignored:\n      return i;\n    case PieceStickering.OrientationStickers: // TODO: Hack for centers. This shouldn't be needed.\n      return o;\n    case PieceStickering.Invisible: // TODO: Hack for centers. This shouldn't be needed.\n      return invisiblePiece;\n    case PieceStickering.IgnoreNonPrimary:\n      return riiii;\n    case PieceStickering.PermuteNonPrimary:\n      return drrrr;\n    case PieceStickering.Ignoriented:\n      return diiii;\n    case PieceStickering.OrientationWithoutPermutation:\n      return oiiii;\n  }\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toAppearance(): PuzzleAppearance {\n    const appearance: PuzzleAppearance = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceAppearance[] = [];\n      const orbitAppearance: OrbitAppearance = {\n        pieces,\n      };\n      appearance.orbits[orbitName] = orbitAppearance;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceAppearance(pieceStickering));\n      }\n    }\n    return appearance;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] =\n          !pieceSet.stickerings.get(orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitName].permutation[i] !== i ||\n          transformation.transformationData[orbitName].orientation[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  // orbits(orbitNames: string[]): PieceSet {\n  //   const pieceSet = new PieceAnnotation<boolean>(this.def, false);\n  //   for (const orbitName of orbitNames) {\n  //     pieceSet.stickerings.get(orbitName)!.fill(true);\n  //   }\n  //   return pieceSet;\n  // }\n\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const [orbitName, orbitDef] of Object.entries(this.def.orbits)) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDef.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n", "import type { TwistyPlayer } from \"../../twisty\";\nimport {\n  PieceStickering,\n  PuzzleStickering,\n  StickeringManager,\n} from \"./appearance\";\n\ntype Stickerer = (\n  puzzleStickering: PuzzleStickering,\n  m: StickeringManager,\n) => void;\n\nlet globalCustomStickerer: Stickerer = () => {};\n\nfunction setGlobalCustomStickerer(stickerer: Stickerer): void {\n  (async () => {\n    globalCustomStickerer = stickerer;\n\n    const players: TwistyPlayer[] = Array.from(\n      document.body.querySelectorAll(\"twisty-player\"),\n    );\n    console.log(`Setting the custom stickering for ${players.length} players!`);\n    const successPromises = [];\n    for (const player of players) {\n      successPromises.push(\n        (async () => {\n          const stickering =\n            await player.experimentalModel.twistySceneModel.stickering.get();\n          player.experimentalStickering =\n            stickering === \"experimental-global-custom-1\"\n              ? \"experimental-global-custom-2\"\n              : \"experimental-global-custom-1\";\n        })(),\n      );\n    }\n    await Promise.all(successPromises);\n    console.log(\"Success!\");\n  })();\n}\n\nexport function useGlobalCustomStickerer(\n  puzzleStickering: PuzzleStickering,\n  m: StickeringManager,\n): void {\n  globalCustomStickerer(puzzleStickering, m);\n}\n\nif (\n  globalThis.location &&\n  new URL(location.href).searchParams.get(\"global-custom-stickerer\") === \"true\"\n) {\n  (window as any).setGlobalCustomStickerer = setGlobalCustomStickerer;\n  (window as any).PieceStickering = PieceStickering;\n  console.log(\n    \"Global custom stickerer enabled! (using: global-custom-stickerer=true)\",\n  );\n  console.log(\n    \"Look here for inspiration:\",\n    \"https://github.com/cubing/cubing.js/blob/81b5cab3e27d8defb39dd1e0a10bc9e8ba894d26/src/cubing/puzzles/stickerings/cube-stickerings.ts#L67\",\n  );\n}\n", "import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PuzzleAppearance,\n  PuzzleStickering,\n  StickeringManager,\n  PieceSet,\n  PieceStickering,\n} from \"./appearance\";\nimport { useGlobalCustomStickerer } from \"./global-custom-stickering-hack\";\n\n// TODO: cache calculations?\nexport async function cubeAppearance(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const E = (): PieceSet => m.not(orUD());\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n  const orFB = (): PieceSet => m.or(m.moves([\"F\", \"B\"]));\n  const S = (): PieceSet => m.not(orFB());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const centerU = (): PieceSet => m.and([LL(), M(), S()]);\n\n  const edgeFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), m.not(orUD())]);\n  const cornerDFR = (): PieceSet => m.and(m.moves([\"D\", \"R\", \"F\"]));\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  const CENTERS = (): PieceSet =>\n    m.or([m.and([M(), E()]), m.and([M(), S()]), m.and([E(), S()])]);\n  const EDGES = (): PieceSet =>\n    m.or([\n      m.and([M(), orUD(), orFB()]),\n      m.and([E(), orLR(), orFB()]),\n      m.and([S(), orUD(), orLR()]),\n    ]);\n  const CORNERS = (): PieceSet => m.not(m.or([CENTERS(), EDGES()]));\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerU(), PieceStickering.Dim); // TODO: why is this needed?\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerU(), PieceStickering.Regular); // TODO: why is this needed?\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerU(), PieceStickering.Dim); // TODO: why is this needed?\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\":\n      dimF2L();\n      setPLL();\n      break;\n    case \"CLS\":\n      dimF2L();\n      puzzleStickering.set(\n        m.and(m.moves([\"D\", \"R\", \"F\"])),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), M(), S()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"OLL\":\n      dimF2L();\n      setOLL();\n      break;\n    case \"COLL\":\n      dimF2L();\n      setPLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"OCLL\":\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"CLL\":\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    case \"ELL\":\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    case \"ELS\":\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    case \"LL\":\n      dimF2L();\n      break;\n    case \"F2L\":\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    case \"ZBLL\":\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerU(), PieceStickering.Dim); // why is this needed?\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"ZBLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    case \"WVLS\":\n    // fallthrough\n    case \"VLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    case \"LS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerU(), PieceStickering.Dim);\n      break;\n    case \"EO\":\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    case \"EOline\":\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    case \"EOcross\":\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    case \"CMLL\":\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"L6E\":\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    case \"L6EO\":\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.OrientationStickers,\n      ); // TODO: why is this needed?\n      break;\n    case \"Daisy\":\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"Cross\":\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    case \"2x2x2\":\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    case \"2x2x3\":\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    case \"Void Cube\":\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    case \"picture\":\n    // fallthrough\n    case \"invisible\":\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    case \"centers-only\":\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    case \"experimental-global-custom-1\":\n    // fallthrough\n    case \"experimental-global-custom-2\":\n      useGlobalCustomStickerer(puzzleStickering, m);\n      break;\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toAppearance();\n}\n\nexport async function cubeStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"PLL\",\n    \"CLS\",\n    \"OLL\",\n    \"COLL\",\n    \"OCLL\",\n    \"ELL\",\n    \"ELS\",\n    \"LL\",\n    \"F2L\",\n    \"ZBLL\",\n    \"ZBLS\",\n    \"WVLS\",\n    \"VLS\",\n    \"LS\",\n    \"EO\",\n    \"EOline\",\n    \"EOcross\",\n    \"CMLL\",\n    \"L6E\",\n    \"L6EO\",\n    \"Daisy\",\n    \"Cross\",\n    \"2x2x2\",\n    \"2x2x3\",\n    \"Void Cube\",\n    \"picture\",\n    \"invisible\",\n    \"centers-only\",\n  ];\n}\n", "export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n", "import { KPuzzle, KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../stickerings/cube-stickerings\";\nimport { getCached } from \"./lazy-cached\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(this.pg(), this.id));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return cubeAppearance(this, stickering);\n  }\n  stickerings = cubeStickerings;\n}\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../../stickerings/cube-stickerings\";\n\nexport const cube2x2x2: PuzzleLoader = {\n  id: \"2x2x2\",\n  fullName: \"2\u00D72\u00D72 Cube\",\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"./2x2x2.kpuzzle.json\")).cube2x2x2KPuzzleDefinition,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"./2x2x2.kpuzzle.svg\")).default;\n  },\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  appearance: (stickering: ExperimentalStickering): Promise<PuzzleAppearance> =>\n    cubeAppearance(cube2x2x2, stickering),\n  stickerings: cubeStickerings,\n};\n", "// Include 3x3x3 in the main bundle for better performance.\nimport { experimental3x3x3KPuzzle } from \"../../../kpuzzle\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../../stickerings/cube-stickerings\";\n\nexport const cube3x3x3: PuzzleLoader = {\n  id: \"3x3x3\",\n  fullName: \"3\u00D73\u00D73 Cube\",\n  inventedBy: [\"Ern\u0151 Rubik\"],\n  inventionYear: 1974, // https://en.wikipedia.org/wiki/Rubik%27s_Cube#Conception_and_development\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"./3x3x3.kpuzzle.svg\")).default;\n  }),\n  llSVG: getCached(async () => {\n    return (await import(\"./3x3x3-ll.kpuzzle.svg\")).default;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  appearance: (stickering: ExperimentalStickering): Promise<PuzzleAppearance> =>\n    cubeAppearance(cube3x3x3, stickering),\n  stickerings: cubeStickerings,\n};\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const clock: PuzzleLoader = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988, // Patent application year: https://www.jaapsch.net/puzzles/patents/us4869506.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"./clock.kpuzzle.json\")).clockKPuzzleDefinition,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"./clock.kpuzzle.svg\")).default;\n  }),\n};\n", "import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PuzzleAppearance,\n  PuzzleStickering,\n  StickeringManager,\n  PieceSet,\n  PieceStickering,\n} from \"./appearance\";\n\nexport async function ftoStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const experimentalFTO_FC = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = (): PieceSet =>\n    m.or([\n      experimentalFTO_F2T(),\n      m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))]),\n    ]);\n  const experimentalFTO_L2C = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"U\"), m.move(\"F\")]),\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n  const experimentalFTO_LBT = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_FC()),\n        PieceStickering.Ignored,\n      );\n      break;\n    case \"experimental-fto-f2t\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_F2T()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_FC(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-sc\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_SC()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_F2T(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-l2c\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_L2C()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_SC(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-lbt\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_LBT()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_L2C(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-l3t\":\n      puzzleStickering.set(experimentalFTO_LBT(), PieceStickering.Dim);\n      break;\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toAppearance();\n}\n\nexport async function ftoStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\",\n  ];\n}\n", "import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  ftoStickering,\n  ftoStickerings,\n} from \"../../stickerings/fto-stickerings\";\n\nclass FTOPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"], // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n      inventionYear: 1983, // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n    });\n  }\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return ftoStickering(this, stickering);\n  }\n  stickerings = ftoStickerings;\n  svg = getCached(async () => {\n    return (await import(\"./fto.kpuzzle.svg\")).ftoSVG;\n  });\n}\n\nexport const fto = new FTOPuzzleLoader();\n", "import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"./appearance\";\nimport { cubeAppearance } from \"./cube-stickerings\";\n\n// TODO: cache calculations?\nexport async function megaminxAppearance(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  switch (stickering) {\n    case \"full\":\n    case \"F2L\":\n    case \"LL\":\n      return cubeAppearance(puzzleLoader, stickering);\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n  }\n  return cubeAppearance(puzzleLoader, \"full\");\n}\n\nexport async function megaminxStickerings(): Promise<ExperimentalStickering[]> {\n  return [\"full\", \"F2L\", \"LL\"];\n}\n", "import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  megaminxAppearance,\n  megaminxStickerings,\n} from \"../../stickerings/megaminx-stickerings\";\n\nclass MegaminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      // Too many simultaneous inventors to name.\n      inventionYear: 1981, // Earliest date from https://www.jaapsch.net/puzzles/megaminx.htm\n    });\n  }\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return megaminxAppearance(this, stickering);\n  }\n  stickerings = megaminxStickerings;\n}\n\nexport const megaminx = new MegaminxPuzzleLoader();\n", "import { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\nclass PyraminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"],\n    });\n  }\n  svg = getCached(async () => {\n    return (await import(\"./pyraminx.kpuzzle.svg\")).default;\n  });\n}\n\nexport const pyraminx = new PyraminxPuzzleLoader();\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const square1: PuzzleLoader = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hr\u0161el\", \"Vojtech Kopsk\u00FD\"],\n  inventionYear: 1990, // Czech patent application year: http://spisy.upv.cz/Patents/FullDocuments/277/277266.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (\n          await import(\"./sq1-hyperorbit.kpuzzle.json\")\n        ).sq1HyperOrbitKPuzzleDefinition,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"./sq1-hyperorbit.kpuzzle.svg\")).default;\n  }),\n};\n", "import type { PuzzleLoader } from \"../..\";\nimport type { Move } from \"../../../alg\";\nimport { KPuzzle, KTransformationData } from \"../../../kpuzzle\";\nimport type { ExperimentalPGNotation } from \"../../../puzzle-geometry\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\n// TODO: Make this consistent with Megaminx corners\nexport const kilominx: PuzzleLoader = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(async () => {\n    const pg = await asyncGetPuzzleGeometry(\"megaminx + chopasaurus\");\n    const kpuzzleDefinition = JSON.parse(\n      JSON.stringify(pg.getKPuzzleDefinition(true)),\n    );\n    delete kpuzzleDefinition.orbits.CENTERS;\n    delete kpuzzleDefinition.orbits.CENTERS2;\n    delete kpuzzleDefinition.startStateData.CENTERS;\n    delete kpuzzleDefinition.startStateData.CENTERS2;\n    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {\n      delete (moveDefinition as any).CENTERS;\n      delete (moveDefinition as any).CENTERS2;\n    }\n    kpuzzleDefinition.name = \"kilominx\";\n    delete kpuzzleDefinition.experimentalPuzzleDescription;\n    const puzzleGeometry = await import(\"../../../puzzle-geometry\");\n    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n      pg,\n      pg.getOrbitsDef(true),\n    );\n    const kpuzzle = new KPuzzle(kpuzzleDefinition, {\n      experimentalPGNotation: {\n        lookupMove: (move: Move): KTransformationData | null => {\n          if (move.toString() === \"x2\" || move.toString() === \"x2'\") {\n            return x2Transformation.transformationData;\n          }\n          return pgNotation.lookupMove(move);\n        },\n      } as ExperimentalPGNotation,\n    });\n    const x2Transformation = kpuzzle.algToTransformation(\"Rv2 Fv Uv'\");\n    kpuzzleDefinition.moves[\"x2\"] = x2Transformation;\n    return kpuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"./kilominx.kpuzzle.svg\")).kilominxSVG;\n  }),\n};\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const rediCube: PuzzleLoader = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  // Announced 2009-07-21: https://www.youtube.com/watch?v=cjfMzA1u3vM\n  // https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1520\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"./redi_cube.kpuzzle.json\")).rediCubeKPuzzleDefinition,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"./redi_cube.kpuzzle.svg\")).rediCubeSVG;\n  },\n};\n", "export { experimental3x3x3KPuzzle } from \"../kpuzzle\";\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"./customPGPuzzleLoader\";\nexport { eventInfo, wcaEventInfo } from \"./events\";\nexport { getFaceletAppearance as experimentalGetFaceletAppearance } from \"./stickerings/appearance\";\nexport type {\n  FaceletMeshAppearance as ExperimentalFaceletMeshAppearance,\n  PuzzleAppearance as ExperimentalPuzzleAppearance,\n} from \"./stickerings/appearance\";\nexport { cubeAppearance as experimentalCubeAppearance } from \"./stickerings/cube-stickerings\";\nexport type { PuzzleLoader };\nexport { cube2x2x2, cube3x3x3 };\n\nimport { CubePGPuzzleLoader, PGPuzzleLoader } from \"./async/async-pg3d\";\nimport { cube2x2x2 } from \"./implementations/2x2x2\";\nimport { cube3x3x3 } from \"./implementations/3x3x3\";\nimport { clock } from \"./implementations/clock\";\nimport { fto } from \"./implementations/fto\";\nimport { megaminx } from \"./implementations/megaminx\";\nimport { pyraminx } from \"./implementations/pyraminx\";\nimport { square1 } from \"./implementations/square1\";\nimport { kilominx } from \"./implementations/kilominx\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\nimport { rediCube } from \"./implementations/redi-cube\";\n\nexport const puzzles: Record<string, PuzzleLoader> = {\n  /******** Start of WCA Puzzles *******/\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": new CubePGPuzzleLoader({ id: \"4x4x4\", fullName: \"4\u00D74\u00D74 Cube\" }),\n  \"5x5x5\": new CubePGPuzzleLoader({ id: \"5x5x5\", fullName: \"5\u00D75\u00D75 Cube\" }),\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"6\u00D76\u00D76 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"7\u00D77\u00D77 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"40\u00D740\u00D740 Cube\",\n  }),\n  // 3x3x3 Blindfolded\n  // 3x3x3 Fewest Moves\n  // 3x3x3 One-Handed\n  clock,\n  \"megaminx\": megaminx,\n  pyraminx,\n  \"skewb\": new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"], // https://www.jaapsch.net/puzzles/skewb.htm\n    // inventionYear: 1982, // 1982 is actually the year of Hofstadter's column.\n  }),\n  square1,\n  // 4x4x4 Blindfolded\n  // 5x5x5 Blindfolded\n  /******** End of WCA puzzles ********/\n  \"fto\": fto,\n  \"gigaminx\": new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006, // Earliest date from https://www.twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1475\n  }),\n  \"master_tetraminx\": new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"], // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n    inventionYear: 2002, // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n  }),\n  kilominx,\n  \"redi_cube\": rediCube,\n};\n"],
  "mappings": "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",
  "names": []
}
