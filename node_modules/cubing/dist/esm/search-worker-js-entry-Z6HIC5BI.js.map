{
  "version": 3,
  "sources": ["../../src/cubing/search/inside/solve/tremble.ts", "../../src/cubing/search/inside/solve/puzzles/2x2x2.ts", "../../src/cubing/search/inside/solve/puzzles/4x4x4.ts", "../../src/cubing/search/inside/solve/puzzles/big-cubes.ts", "../../src/cubing/search/inside/solve/puzzles/5x5x5.ts", "../../src/cubing/search/inside/solve/puzzles/fto.ts", "../../src/cubing/search/inside/solve/puzzles/kilominx.ts", "../../src/cubing/search/inside/solve/puzzles/master_tetraminx.ts", "../../src/cubing/search/inside/solve/puzzles/megaminx.ts", "../../src/cubing/search/inside/solve/puzzles/pyraminx.ts", "../../src/cubing/search/inside/solve/puzzles/redi_cube.ts", "../../src/cubing/search/inside/solve/puzzles/skewb.ts", "../../src/cubing/search/inside/solve/puzzles/sq1.ts", "../../src/cubing/search/inside/api.ts", "../../src/cubing/search/inside/search-worker-js-entry.js"],
  "sourcesContent": ["import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\nimport type { KState } from \"../../../kpuzzle/KState\";\nimport { experimentalCountMoves } from \"../../../notation\";\nimport { randomChoiceFactory } from \"../../../vendor/random-uint-below\";\nimport type { SGSAction, SGSCachedData } from \"./parseSGS\";\n\nconst DEFAULT_STAGE1_DEPTH_LIMIT = 2; // Moderately performant default.\n\nconst DOUBLECHECK_PLACED_PIECES = true;\nconst DEBUG = false;\n\n// TODO: Take moves instead of move names?\nfunction calculateMoves(\n  kpuzzle: KPuzzle,\n  moveNames: string[],\n): {\n  move: Move;\n  transformation: KTransformation;\n}[] {\n  const searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[] = [];\n  // const identity = identityTransformation(def); // TODO\n  // TODO: Make it easy to filter moves.\n  moveNames.forEach(function (moveName) {\n    const rootMove = new Move(moveName);\n    if (rootMove.amount !== 1) {\n      throw new Error(\n        \"SGS cannot handle def moves with an amount other than 1 yet.\",\n      );\n    }\n    let transformation = kpuzzle.identityTransformation();\n    // eslint-disable-next-line no-constant-condition\n    for (let i = 1; true; i++) {\n      transformation = transformation.applyMove(rootMove);\n      if (transformation.isIdentityTransformation()) {\n        break;\n      }\n      searchMoves.push({\n        move: rootMove.modified({ amount: i }),\n        transformation,\n      });\n    }\n  });\n  return searchMoves;\n}\n\n// function badRandomMoves(moves: string[], ksp: KSolvePuzzle): KSolvePuzzleState {\n//   // var sum = 0;\n//   var scramble = \"\";\n//   for (var i = 0; i < 1000; i++) {\n//     scramble = scramble + \" \" + moves[Math.floor(moves.length * Math.random())];\n//   }\n//   // var sol = \"\";\n//   const indexer = new TreeAlgIndexer(ksp, Alg.fromString(scramble));\n//   return indexer.transformAtIndex(indexer.numMoves()) as any; // TODO\n// }\n\nexport class TrembleSolver {\n  private searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[];\n\n  constructor(\n    private kpuzzle: KPuzzle,\n    private sgs: SGSCachedData,\n    trembleMoveNames?: string[],\n  ) {\n    this.searchMoves = calculateMoves(\n      this.kpuzzle,\n      trembleMoveNames ?? Object.keys(this.kpuzzle.definition.moves),\n    );\n  }\n\n  // public badRandomMoves(): KSolvePuzzleState {\n  //   return badRandomMoves(this.moves, this.ksp);\n  // }\n\n  public async solve(\n    state: KState,\n    stage1DepthLimit: number = DEFAULT_STAGE1_DEPTH_LIMIT,\n    quantumMoveOrder?: (quantumMove: QuantumMove) => number,\n  ): Promise<Alg> {\n    const transformation = state.experimentalToTransformation();\n    if (!transformation) {\n      throw new Error(\n        \"distinguishable pieces are not supported in tremble solver yt\",\n      );\n    }\n    let bestAlg: Alg | null = null;\n    let bestLen = 1000000;\n    const recur = (\n      recursiveTransformation: KTransformation, // TODO: Support KStatq1\n      togo: number,\n      sofar: Alg,\n    ) => {\n      // console.log(\"recur\");\n      if (togo === 0) {\n        const sgsAlg = this.sgsPhaseSolve(recursiveTransformation, bestLen);\n        if (!sgsAlg) {\n          return;\n        }\n        // console.log(\"sgs done!\", sofar.toString(), \"|\", sgsAlg.toString());\n        const newAlg = sofar\n          .concat(sgsAlg)\n          .simplify({ collapseMoves: true, quantumMoveOrder });\n\n        const len = experimentalCountMoves(newAlg);\n        if (bestAlg === null || len < bestLen) {\n          if (DEBUG) {\n            console.log(`New best (${len} moves): ${newAlg.toString()}`);\n            console.log(`Tremble moves are: ${sofar.toString()}`);\n          }\n          bestAlg = newAlg;\n          bestLen = len;\n        }\n        return;\n      }\n      for (const searchMove of this.searchMoves) {\n        recur(\n          recursiveTransformation.applyTransformation(\n            searchMove.transformation,\n          ),\n          togo - 1,\n          sofar.concat([searchMove.move]),\n        );\n      }\n    };\n    for (let d = 0; d <= stage1DepthLimit; d++) {\n      recur(transformation, d, new Alg());\n    }\n    if (bestAlg === null) {\n      throw new Error(\"SGS search failed.\");\n    }\n    return bestAlg;\n  }\n\n  private sgsPhaseSolve(\n    initialTransformation: KTransformation, // TODO: Handle KState\n    bestLenSofar: number,\n  ): Alg | null {\n    // const pieceNames = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\n    // function loggo(s: string) {\n    //   // console.warn(s);\n    //   // document.body.appendChild(document.createElement(\"div\")).textContent = s;\n    // }\n\n    // console.log(\"sgsPhaseSolve\");\n    const algBuilder = new AlgBuilder();\n    let transformation = initialTransformation;\n    for (const step of this.sgs.ordering) {\n      const cubieSeq = step.pieceOrdering;\n      let key = \"\";\n      const inverseTransformation = transformation.invert();\n      for (let i = 0; i < cubieSeq.length; i++) {\n        const loc = cubieSeq[i];\n        const orbitName = loc.orbitName;\n        const idx = loc.permutationIdx;\n        key += ` ${inverseTransformation.transformationData[orbitName].permutation[idx]} ${inverseTransformation.transformationData[orbitName].orientation[idx]}`;\n      }\n      // console.log(key, step.lookup);\n      const info = step.lookup[key];\n      if (!info) {\n        throw new Error(\"Missing algorithm in sgs or esgs?\");\n      }\n      algBuilder.experimentalPushAlg(info.alg);\n      if (algBuilder.experimentalNumUnits() >= bestLenSofar) {\n        return null;\n      }\n      transformation = transformation.applyTransformation(info.transformation);\n      if (DOUBLECHECK_PLACED_PIECES) {\n        for (let i = 0; i < cubieSeq.length; i++) {\n          const location = cubieSeq[i];\n          const orbitName = location.orbitName;\n          const idx = location.permutationIdx;\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientation[idx] !== 0\n          ) {\n            throw new Error(\"bad SGS :-(\");\n          }\n        }\n      }\n    }\n    return algBuilder.toAlg();\n  }\n}\n\nexport async function randomStateFromSGS(\n  kpuzzle: KPuzzle,\n  sgs: SGSCachedData,\n): Promise<KState> {\n  const randomChoice = await randomChoiceFactory<SGSAction>(); // TODO: make this sync by putting the factory into a TLA\n\n  let transformation = kpuzzle.identityTransformation();\n  for (const step of sgs.ordering) {\n    const sgsAction = randomChoice(Object.values(step.lookup));\n    transformation = transformation.applyTransformation(\n      sgsAction.transformation,\n    );\n  }\n  return transformation.toKState();\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KPuzzle } from \"../../../../kpuzzle\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { puzzles } from \"../../../../puzzles\";\nimport {\n  randomPermute,\n  randomUIntBelowFactory,\n} from \"../../../../vendor/random-uint-below\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\n\n// Empirical ly determined depth:\n// - \u224811 moves on average (as opposed to >13 moves for depth 2),\n// - in close to 40ms(on a MacBook Pro).\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgsCachedData: SGSCachedData = await (\n        await import(\"./2x2x2.sgs.json\")\n      ).cachedData222();\n      return new TrembleSolver(\n        await puzzles[\"2x2x2\"].kpuzzle(),\n        sgsCachedData,\n        \"URFLBD\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitialize222(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: fix def consistency.\nexport async function solve222(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(state, TREMBLE_DEPTH, () => 4); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\n// TODO: factor out and test.\nasync function mutatingRandomizeOrbit(\n  kpuzzle: KPuzzle,\n  orbitName: string,\n  state: KState,\n  options?: { orientationSum?: number },\n): Promise<void> {\n  const randomUIntBelow = await randomUIntBelowFactory();\n  await randomPermute(state.stateData[orbitName].pieces);\n\n  const orbitDef = kpuzzle.definition.orbits[orbitName];\n  const ori = state.stateData[orbitName].orientation;\n\n  let sum = 0;\n  for (let i = 0; i < orbitDef.numPieces; i++) {\n    const o = randomUIntBelow(orbitDef.numOrientations);\n    ori[i] = o;\n    sum += o;\n  }\n\n  // console.log(\"aaaa\", options && \"orientationSum\" in options);\n  if (options && \"orientationSum\" in options) {\n    // console.log(\"sfdsf\", options!.orientationSum),\n    ori[0] =\n      (((ori[0] + options.orientationSum! - sum) % orbitDef.numOrientations) +\n        orbitDef.numOrientations) %\n      orbitDef.numOrientations;\n  }\n}\n\n// TODO: Use SGS?\nexport async function random222State(): Promise<KState> {\n  const kpuzzle = await puzzles[\"2x2x2\"].kpuzzle();\n  const stateCopy: KState = new KState(\n    kpuzzle,\n    JSON.parse(JSON.stringify(kpuzzle.startState().stateData)),\n  ); // TODO\n  await mutatingRandomizeOrbit(kpuzzle, \"CORNERS\", stateCopy, {\n    orientationSum: 0,\n  });\n  return stateCopy;\n}\n\nexport async function random222Scramble(): Promise<Alg> {\n  return await solve222(await random222State());\n}\n", "import type { Alg } from \"../../../../alg\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\n\nconst randomSuffixes = [\n  [null, \"x\", \"x2\", \"x'\", \"z\", \"z'\"],\n  [null, \"y\", \"y2\", \"y'\"],\n];\n\nlet cachedImport: Promise<\n  typeof import(\"../../../../vendor/cstimer/src/js/scramble/444-solver\")\n> | null = null;\nfunction dynamicScramble444(): Promise<\n  typeof import(\"../../../../vendor/cstimer/src/js/scramble/444-solver\")\n> {\n  return (cachedImport ??= import(\n    \"../../../../vendor/cstimer/src/js/scramble/444-solver\"\n  ));\n}\n\nexport async function initialize444(): Promise<void> {\n  return (await dynamicScramble444()).initialize();\n}\n\nexport async function random444Scramble(): Promise<Alg> {\n  return (await dynamicScramble444()).random444Scramble();\n}\n\nexport async function random444OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random444Scramble(), randomSuffixes);\n}\n", "import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../../alg\";\nimport {\n  randomChoiceFactory,\n  randomUIntBelowFactory,\n} from \"../../../../vendor/random-uint-below\";\n\nfunction numMoves(n: number): number {\n  switch (n) {\n    case 5:\n      return 60;\n    case 6:\n      return 80;\n    default:\n      return 100;\n  }\n}\n\nconst axesFaces = [\n  [\"U\", \"D\"],\n  [\"L\", \"R\"],\n  [\"F\", \"B\"],\n];\nconst axesMovesCache: Map<number, QuantumMove[][]> = new Map();\nfunction cachedAxesMoves(n: number): QuantumMove[][] {\n  const existing = axesMovesCache.get(n);\n  if (existing) {\n    return existing;\n  }\n  const axesMoves = [];\n  for (const faces of axesFaces) {\n    const axisMoveFamilies: QuantumMove[] = [];\n    axesMoves.push(axisMoveFamilies);\n\n    for (const face of faces) {\n      axisMoveFamilies.push(new QuantumMove(face));\n      if (n > 3) {\n        axisMoveFamilies.push(new QuantumMove(`${face}w`));\n      }\n      for (let i = 3; i <= n / 2; i++) {\n        axisMoveFamilies.push(new QuantumMove(`${face}w`, i));\n      }\n    }\n  }\n  axesMovesCache.set(n, axesMoves);\n  return axesMoves;\n}\n\n// TODO: Document this algorithm and compare to TNoodle.\nexport async function bigCubeRandomMoves(n: number): Promise<Alg> {\n  const randomUintBelow = await randomUIntBelowFactory();\n  const randomChoice = await randomChoiceFactory<QuantumMove>();\n  const randomNumChoice = randomChoice as any as (arr: Array<number>) => number; // TODO: Avoid needing multiple instantiations or recasting.\n\n  const axesMoves = cachedAxesMoves(n);\n\n  const cachedNumMoves = numMoves(n);\n  const algBuilder = new AlgBuilder();\n  let currentAxisIdx = 0;\n  const currentAxisQuantumMoves = new Set();\n  while (algBuilder.experimentalNumUnits() < cachedNumMoves) {\n    const newAxisIdx = randomUintBelow(3);\n    if (newAxisIdx !== currentAxisIdx) {\n      currentAxisQuantumMoves.clear();\n    }\n    currentAxisIdx = newAxisIdx;\n\n    const quantumMove = randomChoice(axesMoves[currentAxisIdx]);\n    const quantumMoveStr = quantumMove.toString();\n    if (currentAxisQuantumMoves.has(quantumMoveStr)) {\n      // Skip duplicates and resample with replacement.\n      continue;\n    }\n    currentAxisQuantumMoves.add(quantumMoveStr);\n    algBuilder.push(new Move(quantumMove, randomNumChoice([1, 2, -1])));\n  }\n\n  return algBuilder.toAlg();\n}\n", "import type { Alg } from \"../../../../alg\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { bigCubeRandomMoves } from \"./big-cubes\";\n\nconst randomSuffixes = [\n  [null, \"3Rw\", \"3Rw2\", \"3Rw'\", \"3Fw\", \"3Fw'\"],\n  [null, \"3Dw\", \"3Dw2\", \"3Dw'\"],\n];\n\nexport async function oriented555RandomMoves(): Promise<Alg> {\n  return addOrientationSuffix(await bigCubeRandomMoves(5), randomSuffixes);\n}\n", "import { Alg } from \"../../../../alg\";\nimport type { KState } from \"../../../../kpuzzle/KState\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgs = await import(\"./fto.dynamic\");\n      const json: SGSCachedData = await sgs.sgsDataFTO();\n      return new TrembleSolver(await puzzles[\"fto\"].kpuzzle(), json, [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"L\",\n        \"D\",\n        \"B\",\n        \"BR\",\n        \"BL\",\n      ]);\n    })())\n  );\n}\n\nexport async function preInitializeFTO(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveFTO(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    state,\n    TREMBLE_DEPTH,\n    () => 3, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomFTOScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  const { randomFTOScrambleString } = await import(\"./fto.dynamic\");\n  return new Alg(await randomFTOScrambleString());\n}\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\n\nexport async function randomKilominxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  const { getRandomKilominxScramble } = await import(\n    \"../../../../vendor/xyzzy/kilosolver\"\n  );\n  return getRandomKilominxScramble();\n}\n", "import { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\n\nexport async function randomMasterTetraminxScramble(): Promise<Alg> {\n  const { randomMasterTetraminxScrambleString } = await import(\n    \"../../../../vendor/xyzzy/master_tetraminx-solver.js\"\n  );\n  mustBeInsideWorker();\n  return new Alg(await randomMasterTetraminxScrambleString());\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KStateData } from \"../../../../kpuzzle\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { cachedMegaminxKPuzzleWithoutMO } from \"./megaminx.sgs.json\";\n\nconst TREMBLE_DEPTH = 2;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgs = await import(\"./megaminx.sgs.json\");\n      const json: SGSCachedData = await sgs.cachedSGSDataMegaminx();\n      return new TrembleSolver(await cachedMegaminxKPuzzleWithoutMO(), json, [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"L\",\n        \"BR\",\n        \"BL\",\n        \"FR\",\n        \"FL\",\n        \"DR\",\n        \"DL\",\n        \"B\",\n        \"D\",\n      ]);\n    })())\n  );\n}\n\nexport async function preInitializeMegaminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveMegaminx(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const stateDataWithoutMO: KStateData = JSON.parse(\n    JSON.stringify(state.stateData),\n  );\n  stateDataWithoutMO.CENTERS.orientation = new Array(12).fill(0);\n  const stateWithoutMO = new KState(\n    await cachedMegaminxKPuzzleWithoutMO(),\n    stateDataWithoutMO,\n  );\n  const alg = await trembleSolver.solve(\n    stateWithoutMO,\n    TREMBLE_DEPTH,\n    () => 5, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KState } from \"../../../../kpuzzle/KState\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomStateFromSGS, TrembleSolver } from \"../tremble\";\nimport { sgsDataPyraminxFixedOrientation } from \"./pyraminx.sgs.json\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgs = await import(\"./pyraminx.sgs.json\");\n      const json: SGSCachedData = await sgs.sgsDataPyraminx();\n      return new TrembleSolver(\n        await puzzles.pyraminx.kpuzzle(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializePyraminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solvePyraminx(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(state, TREMBLE_DEPTH, () => 3); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\nexport async function randomPyraminxStateFixedOrientation(): Promise<KState> {\n  mustBeInsideWorker();\n  // Note: this sets all center orientations to 0.\n  return randomStateFromSGS(\n    await puzzles.pyraminx.kpuzzle(),\n    await sgsDataPyraminxFixedOrientation(),\n  );\n}\n\nexport async function randomPyraminxScrambleFixedOrientation(): Promise<Alg> {\n  return solvePyraminx(await randomPyraminxStateFixedOrientation());\n}\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\n\nexport async function randomRediCubeScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  const { getRandomRediCubeScramble } = await import(\n    \"../../../../vendor/xyzzy/redi_cube\"\n  );\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return getRandomRediCubeScramble();\n}\n", "import type { Alg, QuantumMove } from \"../../../../alg\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomStateFromSGS, TrembleSolver } from \"../tremble\";\nimport {\n  sgsDataSkewbFixedCorner,\n  skewbKPuzzleWithoutMOCached,\n} from \"./skewb.sgs.json\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgs = await import(\"./skewb.sgs.json\");\n      const json: SGSCachedData = await sgs.sgsDataSkewb();\n      return new TrembleSolver(\n        await sgs.skewbKPuzzleWithoutMOCached(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializeSkewb(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nfunction resetCenterOrientation(state: KState): KState {\n  return new KState(state.kpuzzle, {\n    CORNERS: state.stateData.CORNERS,\n    CENTERS: {\n      pieces: state.stateData.CENTERS.pieces,\n      orientation: new Array(6).fill(0),\n    },\n  });\n}\n\n// TODO: fix def consistency.\nexport async function solveSkewb(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    resetCenterOrientation(state),\n    TREMBLE_DEPTH,\n    (quantumMove: QuantumMove) => (quantumMove.family === \"y\" ? 4 : 3), // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomSkewbFixedCornerState(): Promise<KState> {\n  // Note: this sets all center orientations to 0.\n  return randomStateFromSGS(\n    await skewbKPuzzleWithoutMOCached(),\n    await sgsDataSkewbFixedCorner(),\n  );\n}\n\nexport async function randomSkewbFixedCornerScramble(): Promise<Alg> {\n  return solveSkewb(await randomSkewbFixedCornerState());\n}\n", "import { Alg } from \"../../../../alg\";\n\nlet cachedImport: Promise<\n  typeof import(\"../../../../vendor/sq12phase/sq1-solver\")\n> | null = null;\nfunction dynamicScrambleSq1(): Promise<\n  typeof import(\"../../../../vendor/sq12phase/sq1-solver\")\n> {\n  return (cachedImport ??= import(\"../../../../vendor/sq12phase/sq1-solver\"));\n}\n\nexport async function getRandomSquare1Scramble(): Promise<Alg> {\n  return Alg.fromString(\n    await (await dynamicScrambleSq1()).getRandomSquare1ScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../alg\";\nimport type { KStateData } from \"../../kpuzzle\";\nimport { KState } from \"../../kpuzzle\";\nimport { puzzles } from \"../../puzzles\";\nimport { setIsInsideWorker } from \"./inside-worker\";\nimport {\n  preInitialize222,\n  random222Scramble,\n  solve222,\n} from \"./solve/puzzles/2x2x2\";\nimport {\n  initialize333,\n  random333FewestMovesScramble,\n  random333OrientedScramble,\n  random333Scramble,\n  solve333,\n} from \"./solve/puzzles/3x3x3\";\nimport {\n  initialize444,\n  random444OrientedScramble,\n  random444Scramble,\n} from \"./solve/puzzles/4x4x4\";\nimport { oriented555RandomMoves } from \"./solve/puzzles/5x5x5\";\nimport { bigCubeRandomMoves } from \"./solve/puzzles/big-cubes\";\nimport { randomFTOScramble } from \"./solve/puzzles/fto\";\nimport { randomKilominxScramble } from \"./solve/puzzles/kilominx\";\nimport { randomMasterTetraminxScramble } from \"./solve/puzzles/master_tetraminx\";\nimport { solveMegaminx } from \"./solve/puzzles/megaminx\";\nimport {\n  randomPyraminxScrambleFixedOrientation,\n  solvePyraminx,\n} from \"./solve/puzzles/pyraminx\";\nimport { randomRediCubeScramble } from \"./solve/puzzles/redi_cube\";\nimport {\n  randomSkewbFixedCornerScramble,\n  solveSkewb,\n} from \"./solve/puzzles/skewb\";\nimport { getRandomSquare1Scramble } from \"./solve/puzzles/sq1\";\n\nconst IDLE_PREFETCH_TIMEOUT_MS = 1000;\n\nsetIsInsideWorker(true);\n\nlet DEBUG_MEASURE_PERF = true;\nexport function setDebugMeasurePerf(newDebugMeasurePerf: boolean): void {\n  DEBUG_MEASURE_PERF = newDebugMeasurePerf;\n}\n\nfunction now() {\n  return (typeof performance === \"undefined\" ? Date : performance).now();\n}\n\nasync function measurePerf<T>(\n  name: string,\n  f: () => T | Promise<T>,\n  options?: { isPrefetch?: boolean },\n): Promise<T> {\n  if (!DEBUG_MEASURE_PERF) {\n    return f();\n  }\n\n  const start = now();\n  const result = f();\n  if ((result as any)?.then) {\n    await result;\n  }\n  const end = now();\n  console.warn(\n    `${name}${options?.isPrefetch ? \" (prefetched)\" : \"\"}: ${Math.round(\n      end - start,\n    )}ms`,\n  );\n  return result;\n}\n\nconst prefetchPromises: Map<string, Promise<Alg>> = new Map();\n// This would just be a number, except `node` is extremely silly and returns an object instead.\n// https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\nlet queuedPrefetchTimeoutID: ReturnType<typeof setTimeout> | null = null;\n\nasync function randomScrambleForEvent(\n  eventID: string,\n  options?: { isPrefetch?: boolean },\n): Promise<Alg> {\n  switch (eventID) {\n    case \"222\":\n      return measurePerf(\"random222Scramble\", random222Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333\":\n    case \"333oh\":\n    case \"333ft\":\n      return measurePerf(\"random333Scramble\", random333Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333fm\":\n      return measurePerf(\n        \"random333FewestMovesScramble\",\n        random333FewestMovesScramble,\n      );\n    case \"333bf\":\n    case \"333mb\":\n      return measurePerf(\n        \"random333OrientedScramble\",\n        random333OrientedScramble,\n      );\n    case \"444\":\n      return measurePerf(\"random444Scramble\", random444Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"444bf\":\n      return measurePerf(\n        \"random444OrientedScramble\",\n        random444OrientedScramble,\n      );\n    case \"555\":\n      return measurePerf(\n        \"bigCubeScramble(5)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 5),\n      );\n    case \"555bf\":\n      return measurePerf(\"oriented555RandomMoves\", oriented555RandomMoves);\n    case \"666\":\n      return measurePerf(\n        \"bigCubeScramble(6)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 6),\n      );\n    case \"777\":\n      return measurePerf(\n        \"bigCubeScramble(7)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 7),\n      );\n    case \"skewb\":\n      return measurePerf(\n        \"randomSkewbFixedCornerScramble\",\n        randomSkewbFixedCornerScramble,\n      );\n    case \"pyram\":\n      return measurePerf(\n        \"randomPyraminxScrambleFixedOrientation\",\n        randomPyraminxScrambleFixedOrientation,\n      );\n    case \"sq1\":\n      return measurePerf(\"getRandomSquare1Scramble\", getRandomSquare1Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"fto\":\n      return measurePerf(\"randomFTOScramble\", randomFTOScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"master_tetraminx\":\n      return measurePerf(\n        \"randomMasterTetraminxScramble\",\n        randomMasterTetraminxScramble,\n      );\n    case \"kilominx\":\n      return measurePerf(\"randomKilominxScramble\", randomKilominxScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"redi_cube\":\n      return measurePerf(\"randomRediCubeScramble\", randomRediCubeScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    default:\n      throw new Error(`unsupported event: ${eventID}`);\n  }\n}\n\nexport enum PrefetchLevel {\n  Auto = \"auto\",\n  None = \"none\",\n  Immediate = \"immediate\",\n}\n\nlet currentPrefetchLevel = PrefetchLevel.Auto;\n\nexport const insideAPI = {\n  initialize: async (eventID: string) => {\n    switch (eventID) {\n      case \"222\":\n        return measurePerf(\"preInitialize222\", preInitialize222);\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"initialize333\", initialize333);\n      case \"444\":\n        return measurePerf(\"initialize444\", initialize444);\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  },\n\n  setScramblePrefetchLevel(prefetchLevel: PrefetchLevel) {\n    currentPrefetchLevel = prefetchLevel;\n  },\n\n  randomScrambleForEvent: async (eventID: string): Promise<Alg> => {\n    let promise = prefetchPromises.get(eventID);\n    if (promise) {\n      prefetchPromises.delete(eventID);\n    } else {\n      promise = randomScrambleForEvent(eventID);\n    }\n    if (currentPrefetchLevel !== PrefetchLevel.None) {\n      promise.then(() => {\n        // `queuedPrefetch` could be 0, but:\n        // > Passing an invalid ID to clearTimeout() silently does nothing; no exception is thrown.\n        // https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout#notes\n        if (queuedPrefetchTimeoutID) {\n          clearTimeout(queuedPrefetchTimeoutID);\n        }\n        queuedPrefetchTimeoutID = setTimeout(\n          () => {\n            prefetchPromises.set(\n              eventID,\n              randomScrambleForEvent(eventID, {\n                isPrefetch: true,\n              }),\n            );\n          },\n          currentPrefetchLevel === PrefetchLevel.Immediate\n            ? 0\n            : IDLE_PREFETCH_TIMEOUT_MS,\n        );\n      });\n    }\n    return promise;\n  },\n\n  randomScrambleStringForEvent: async (eventID: string): Promise<string> => {\n    return (await insideAPI.randomScrambleForEvent(eventID)).toString();\n  },\n\n  solve333ToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"3x3x3\"].kpuzzle(), stateData);\n    return (await solve333(state)).toString();\n  },\n\n  solve222ToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"2x2x2\"].kpuzzle(), stateData);\n    return (await solve222(state)).toString();\n  },\n\n  solveSkewbToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"skewb\"].kpuzzle(), stateData);\n    return (await solveSkewb(state)).toString();\n  },\n\n  solvePyraminxToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"pyraminx\"].kpuzzle(), stateData);\n    return (await solvePyraminx(state)).toString();\n  },\n\n  solveMegaminxToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"megaminx\"].kpuzzle(), stateData);\n    return (await solveMegaminx(state)).toString();\n  },\n\n  setDebugMeasurePerf: async (measure: boolean): Promise<void> => {\n    setDebugMeasurePerf(measure);\n  },\n};\n\nexport type WorkerInsideAPI = typeof insideAPI;\n", "import { expose } from \"../../vendor/comlink-everywhere/inside\";\nimport { insideAPI } from \"./api\";\n\nexpose(insideAPI);\n"],
  "mappings": "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",
  "names": []
}
