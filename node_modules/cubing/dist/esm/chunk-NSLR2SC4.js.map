{
  "version": 3,
  "sources": ["../../src/cubing/notation/CountMoves.ts", "../../src/cubing/notation/CountAnimatedLeaves.ts"],
  "sourcesContent": ["// TODO: move this file somewhere permanent.\nimport {\n  Alg,\n  Grouping,\n  LineComment,\n  Commutator,\n  Conjugate,\n  Move,\n  Newline,\n  Pause,\n  TraversalUp,\n} from \"../alg\";\n\n/*\n *   For movecount, that understands puzzle rotations.  This code\n *   should be moved to the alg class, probably.\n */\nclass CountMoves extends TraversalUp<number> {\n  constructor(private metric: (move: Move) => number) {\n    super();\n  }\n\n  public traverseAlg(alg: Alg): number {\n    let r = 0;\n    for (const unit of alg.units()) {\n      r += this.traverseUnit(unit);\n    }\n    return r;\n  }\n\n  public traverseGrouping(grouping: Grouping): number {\n    // const unit: Unit = Alg.fromString(\"SDf\");\n    // console.log(unit);\n    const alg: Alg = grouping.alg;\n    return this.traverseAlg(alg) * Math.abs(grouping.amount);\n  }\n\n  public traverseMove(move: Move): number {\n    return this.metric(move);\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(_pause: Pause): number {\n    return 0;\n  }\n\n  public traverseNewline(_newLine: Newline): number {\n    return 0;\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseLineComment(_comment: LineComment): number {\n    return 0;\n  }\n}\n\nfunction isCharUppercase(c: string): boolean {\n  return \"A\" <= c && c <= \"Z\";\n}\n\n// TODO: Implement a puzzle-specific way to calculate this.\nfunction baseMetric(move: Move): number {\n  const fam = move.family;\n  if (\n    (isCharUppercase(fam[0]) && fam[fam.length - 1] === \"v\") ||\n    fam === \"x\" ||\n    fam === \"y\" ||\n    fam === \"z\" ||\n    fam === \"T\"\n  ) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\n// TODO: Implement a puzzle-specific way to calculate this.\nfunction quantumMetric(move: Move): number {\n  const fam = move.family;\n  if (\n    (isCharUppercase(fam[0]) && fam[fam.length - 1] === \"v\") ||\n    fam === \"x\" ||\n    fam === \"y\" ||\n    fam === \"z\" ||\n    fam === \"T\"\n  ) {\n    return 0;\n  } else {\n    return Math.abs(move.amount);\n  }\n}\n\nconst countMovesInstance = new CountMoves(baseMetric);\nexport const countMoves: (alg: Alg) => number =\n  countMovesInstance.traverseAlg.bind(countMovesInstance);\n\nconst countQuantumMovesInstance = new CountMoves(quantumMetric);\nexport const countQuantumMoves: (alg: Alg) => number =\n  countQuantumMovesInstance.traverseAlg.bind(countQuantumMovesInstance);\n", "import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalUp,\n} from \"../alg\";\n\n// TODO: Include Pause, include amounts\nclass CountAnimatedLeaves extends TraversalUp<number, number> {\n  public traverseAlg(alg: Alg): number {\n    let total = 0;\n    for (const part of alg.units()) {\n      total += this.traverseUnit(part);\n    }\n    return total;\n  }\n\n  public traverseGrouping(grouping: Grouping): number {\n    return this.traverseAlg(grouping.alg) * Math.abs(grouping.amount);\n  }\n\n  public traverseMove(_move: Move): number {\n    return 1;\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);\n  }\n\n  public traversePause(_pause: Pause): number {\n    return 1;\n  }\n\n  public traverseNewline(_newline: Newline): number {\n    return 0;\n  }\n\n  public traverseLineComment(_comment: LineComment): number {\n    return 0;\n  }\n}\n\nconst countAnimatedLeavesInstance = new CountAnimatedLeaves();\nexport const countAnimatedLeaves: (alg: Alg) => number =\n  countAnimatedLeavesInstance.traverseAlg.bind(countAnimatedLeavesInstance);\n"],
  "mappings": ";;;;;AAiBA,+BAAyB,YAAoB;AAAA,EAC3C,YAAoB,QAAgC;AAClD;AADkB;AAAA;AAAA,EAIb,YAAY,KAAkB;AACnC,QAAI,IAAI;AACR,eAAW,QAAQ,IAAI,SAAS;AAC9B,WAAK,KAAK,aAAa;AAAA;AAEzB,WAAO;AAAA;AAAA,EAGF,iBAAiB,UAA4B;AAGlD,UAAM,MAAW,SAAS;AAC1B,WAAO,KAAK,YAAY,OAAO,KAAK,IAAI,SAAS;AAAA;AAAA,EAG5C,aAAa,MAAoB;AACtC,WAAO,KAAK,OAAO;AAAA;AAAA,EAGd,mBAAmB,YAAgC;AACxD,WACE,IAAK,MAAK,YAAY,WAAW,KAAK,KAAK,YAAY,WAAW;AAAA;AAAA,EAI/D,kBAAkB,WAA8B;AACrD,WAAO,IAAI,KAAK,YAAY,UAAU,KAAK,KAAK,YAAY,UAAU;AAAA;AAAA,EAIjE,cAAc,QAAuB;AAC1C,WAAO;AAAA;AAAA,EAGF,gBAAgB,UAA2B;AAChD,WAAO;AAAA;AAAA,EAIF,oBAAoB,UAA+B;AACxD,WAAO;AAAA;AAAA;AAIX,yBAAyB,GAAoB;AAC3C,SAAO,OAAO,KAAK,KAAK;AAAA;AAI1B,oBAAoB,MAAoB;AACtC,QAAM,MAAM,KAAK;AACjB,MACG,gBAAgB,IAAI,OAAO,IAAI,IAAI,SAAS,OAAO,OACpD,QAAQ,OACR,QAAQ,OACR,QAAQ,OACR,QAAQ,KACR;AACA,WAAO;AAAA,SACF;AACL,WAAO;AAAA;AAAA;AAKX,uBAAuB,MAAoB;AACzC,QAAM,MAAM,KAAK;AACjB,MACG,gBAAgB,IAAI,OAAO,IAAI,IAAI,SAAS,OAAO,OACpD,QAAQ,OACR,QAAQ,OACR,QAAQ,OACR,QAAQ,KACR;AACA,WAAO;AAAA,SACF;AACL,WAAO,KAAK,IAAI,KAAK;AAAA;AAAA;AAIzB,IAAM,qBAAqB,IAAI,WAAW;AACnC,IAAM,aACX,mBAAmB,YAAY,KAAK;AAEtC,IAAM,4BAA4B,IAAI,WAAW;AAC1C,IAAM,oBACX,0BAA0B,YAAY,KAAK;;;AC/F7C,wCAAkC,YAA4B;AAAA,EACrD,YAAY,KAAkB;AACnC,QAAI,QAAQ;AACZ,eAAW,QAAQ,IAAI,SAAS;AAC9B,eAAS,KAAK,aAAa;AAAA;AAE7B,WAAO;AAAA;AAAA,EAGF,iBAAiB,UAA4B;AAClD,WAAO,KAAK,YAAY,SAAS,OAAO,KAAK,IAAI,SAAS;AAAA;AAAA,EAGrD,aAAa,OAAqB;AACvC,WAAO;AAAA;AAAA,EAGF,mBAAmB,YAAgC;AACxD,WACE,IAAK,MAAK,YAAY,WAAW,KAAK,KAAK,YAAY,WAAW;AAAA;AAAA,EAI/D,kBAAkB,WAA8B;AACrD,WAAO,IAAI,KAAK,YAAY,UAAU,KAAK,KAAK,YAAY,UAAU;AAAA;AAAA,EAGjE,cAAc,QAAuB;AAC1C,WAAO;AAAA;AAAA,EAGF,gBAAgB,UAA2B;AAChD,WAAO;AAAA;AAAA,EAGF,oBAAoB,UAA+B;AACxD,WAAO;AAAA;AAAA;AAIX,IAAM,8BAA8B,IAAI;AACjC,IAAM,sBACX,4BAA4B,YAAY,KAAK;",
  "names": []
}
