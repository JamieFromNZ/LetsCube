import {
  KPuzzle,
  experimental3x3x3KPuzzle
} from "./chunk-HD2CMNE4.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-MGJA5U5O.js";

// src/cubing/puzzles/customPGPuzzleLoader.ts
async function descAsyncGetPuzzleGeometry(desc) {
  const puzzleGeometry = await import("./puzzle-geometry/index.js");
  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {
    allMoves: true,
    orientCenters: true,
    addRotations: true
  });
}
async function asyncGetKPuzzle(desc) {
  const pg = await descAsyncGetPuzzleGeometry(desc);
  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);
  kpuzzleDefinition.name = `description: ${desc}`;
  const puzzleGeometry = await import("./puzzle-geometry/index.js");
  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
  return new KPuzzle(kpuzzleDefinition, {
    experimentalPGNotation: pgNotation
  });
}
var nextCustomID = 1;
function customPGPuzzleLoader(desc, info) {
  const customID = nextCustomID++;
  let cachedKPuzzle = null;
  const puzzleLoader = {
    id: `custom-${customID}`,
    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,
    kpuzzle: async () => {
      return cachedKPuzzle ?? (cachedKPuzzle = asyncGetKPuzzle(desc));
    },
    svg: async () => {
      const pg = await descAsyncGetPuzzleGeometry(desc);
      return pg.generatesvg();
    },
    pg: async () => {
      return descAsyncGetPuzzleGeometry(desc);
    }
  };
  if (info?.inventedBy) {
    puzzleLoader.inventedBy = info.inventedBy;
  }
  if (info?.inventionYear) {
    puzzleLoader.inventionYear = info.inventionYear;
  }
  return puzzleLoader;
}

// src/cubing/puzzles/events.ts
var wcaEvents = {
  "333": { puzzleID: "3x3x3", eventName: "3x3x3 Cube" },
  "222": { puzzleID: "2x2x2", eventName: "2x2x2 Cube" },
  "444": { puzzleID: "4x4x4", eventName: "4x4x4 Cube" },
  "555": { puzzleID: "5x5x5", eventName: "5x5x5 Cube" },
  "666": { puzzleID: "6x6x6", eventName: "6x6x6 Cube" },
  "777": { puzzleID: "7x7x7", eventName: "7x7x7 Cube" },
  "333bf": { puzzleID: "3x3x3", eventName: "3x3x3 Blindfolded" },
  "333fm": { puzzleID: "3x3x3", eventName: "3x3x3 Fewest Moves" },
  "333oh": { puzzleID: "3x3x3", eventName: "3x3x3 One-Handed" },
  "clock": { puzzleID: "clock", eventName: "Clock" },
  "minx": { puzzleID: "megaminx", eventName: "Megaminx" },
  "pyram": { puzzleID: "pyraminx", eventName: "Pyraminx" },
  "skewb": { puzzleID: "skewb", eventName: "Skewb" },
  "sq1": { puzzleID: "square1", eventName: "Square-1" },
  "444bf": { puzzleID: "4x4x4", eventName: "4x4x4 Blindfolded" },
  "555bf": { puzzleID: "5x5x5", eventName: "5x5x5 Blindfolded" },
  "333mb": { puzzleID: "3x3x3", eventName: "3x3x3 Multi-Blind" }
};
function wcaEventInfo(event) {
  return wcaEvents[event] ?? null;
}
var events = {
  ...wcaEvents,
  fto: { puzzleID: "fto", eventName: "Face-Turning Octahedron" },
  master_tetraminx: {
    puzzleID: "master_tetraminx",
    eventName: "Master Tetraminx"
  },
  kilominx: {
    puzzleID: "kilominx",
    eventName: "Kilominx"
  },
  redi_cube: {
    puzzleID: "redi_cube",
    eventName: "Redi Cube"
  }
};
function eventInfo(event) {
  return events[event] ?? null;
}

// src/cubing/puzzles/stickerings/appearance.ts
function getFaceletAppearance(appearance, orbitName, pieceIdx, faceletIdx, hint) {
  const orbitAppearance = appearance.orbits[orbitName];
  const pieceAppearance = orbitAppearance.pieces[pieceIdx];
  if (pieceAppearance === null) {
    return regular;
  }
  const faceletAppearance = pieceAppearance.facelets[faceletIdx];
  if (faceletAppearance === null) {
    return regular;
  }
  if (typeof faceletAppearance === "string") {
    return faceletAppearance;
  }
  if (hint) {
    return faceletAppearance.hintAppearance ?? faceletAppearance.appearance;
  }
  return faceletAppearance.appearance;
}
var PieceStickering = /* @__PURE__ */ ((PieceStickering2) => {
  PieceStickering2["Regular"] = "Regular";
  PieceStickering2["Dim"] = "Dim";
  PieceStickering2["Ignored"] = "Ignored";
  PieceStickering2["OrientationStickers"] = "OrientationStickers";
  PieceStickering2["Invisible"] = "Invisible";
  PieceStickering2["Ignoriented"] = "Ignoriented";
  PieceStickering2["IgnoreNonPrimary"] = "IgnoreNonPrimary";
  PieceStickering2["PermuteNonPrimary"] = "PermuteNonPrimary";
  PieceStickering2["OrientationWithoutPermutation"] = "OrientationWithoutPermutation";
  return PieceStickering2;
})(PieceStickering || {});
var PieceAnnotation = class {
  constructor(kpuzzle, defaultValue) {
    this.stickerings = /* @__PURE__ */ new Map();
    for (const [orbitName, orbitDef] of Object.entries(kpuzzle.definition.orbits)) {
      this.stickerings.set(orbitName, new Array(orbitDef.numPieces).fill(defaultValue));
    }
  }
};
var regular = "regular";
var ignored = "ignored";
var oriented = "oriented";
var invisible = "invisible";
var dim = "dim";
var r = {
  facelets: [regular, regular, regular, regular, regular]
};
var i = {
  facelets: [ignored, ignored, ignored, ignored, ignored]
};
var o = {
  facelets: [oriented, oriented, oriented, oriented, oriented]
};
var invisiblePiece = {
  facelets: [invisible, invisible, invisible, invisible]
};
var riiii = {
  facelets: [regular, ignored, ignored, ignored, ignored]
};
var drrrr = {
  facelets: [dim, regular, regular, regular, regular]
};
var d = {
  facelets: [dim, dim, dim, dim, dim]
};
var diiii = {
  facelets: [dim, ignored, ignored, ignored, ignored]
};
var oiiii = {
  facelets: [oriented, ignored, ignored, ignored, ignored]
};
function getPieceAppearance(pieceStickering) {
  switch (pieceStickering) {
    case "Regular" /* Regular */:
      return r;
    case "Dim" /* Dim */:
      return d;
    case "Ignored" /* Ignored */:
      return i;
    case "OrientationStickers" /* OrientationStickers */:
      return o;
    case "Invisible" /* Invisible */:
      return invisiblePiece;
    case "IgnoreNonPrimary" /* IgnoreNonPrimary */:
      return riiii;
    case "PermuteNonPrimary" /* PermuteNonPrimary */:
      return drrrr;
    case "Ignoriented" /* Ignoriented */:
      return diiii;
    case "OrientationWithoutPermutation" /* OrientationWithoutPermutation */:
      return oiiii;
  }
}
var PuzzleStickering = class extends PieceAnnotation {
  constructor(kpuzzle) {
    super(kpuzzle, "Regular" /* Regular */);
  }
  set(pieceSet, pieceStickering) {
    for (const [orbitName, pieces] of this.stickerings.entries()) {
      for (let i2 = 0; i2 < pieces.length; i2++) {
        if (pieceSet.stickerings.get(orbitName)[i2]) {
          pieces[i2] = pieceStickering;
        }
      }
    }
    return this;
  }
  toAppearance() {
    const appearance = { orbits: {} };
    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {
      const pieces = [];
      const orbitAppearance = {
        pieces
      };
      appearance.orbits[orbitName] = orbitAppearance;
      for (const pieceStickering of pieceStickerings) {
        pieces.push(getPieceAppearance(pieceStickering));
      }
    }
    return appearance;
  }
};
var StickeringManager = class {
  constructor(kpuzzle) {
    this.kpuzzle = kpuzzle;
  }
  and(pieceSets) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      pieceLoop:
        for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
          newPieceSet.stickerings.get(orbitName)[i2] = true;
          for (const pieceSet of pieceSets) {
            if (!pieceSet.stickerings.get(orbitName)[i2]) {
              newPieceSet.stickerings.get(orbitName)[i2] = false;
              continue pieceLoop;
            }
          }
        }
    }
    return newPieceSet;
  }
  or(pieceSets) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      pieceLoop:
        for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
          newPieceSet.stickerings.get(orbitName)[i2] = false;
          for (const pieceSet of pieceSets) {
            if (pieceSet.stickerings.get(orbitName)[i2]) {
              newPieceSet.stickerings.get(orbitName)[i2] = true;
              continue pieceLoop;
            }
          }
        }
    }
    return newPieceSet;
  }
  not(pieceSet) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
        newPieceSet.stickerings.get(orbitName)[i2] = !pieceSet.stickerings.get(orbitName)[i2];
      }
    }
    return newPieceSet;
  }
  all() {
    return this.and(this.moves([]));
  }
  move(moveSource) {
    const transformation = this.kpuzzle.moveToTransformation(moveSource);
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
        if (transformation.transformationData[orbitName].permutation[i2] !== i2 || transformation.transformationData[orbitName].orientation[i2] !== 0) {
          newPieceSet.stickerings.get(orbitName)[i2] = true;
        }
      }
    }
    return newPieceSet;
  }
  moves(moveSources) {
    return moveSources.map((moveSource) => this.move(moveSource));
  }
};

// src/cubing/puzzles/stickerings/global-custom-stickering-hack.ts
var globalCustomStickerer = () => {
};
function setGlobalCustomStickerer(stickerer) {
  (async () => {
    globalCustomStickerer = stickerer;
    const players = Array.from(document.body.querySelectorAll("twisty-player"));
    console.log(`Setting the custom stickering for ${players.length} players!`);
    const successPromises = [];
    for (const player of players) {
      successPromises.push((async () => {
        const stickering = await player.experimentalModel.twistySceneModel.stickering.get();
        player.experimentalStickering = stickering === "experimental-global-custom-1" ? "experimental-global-custom-2" : "experimental-global-custom-1";
      })());
    }
    await Promise.all(successPromises);
    console.log("Success!");
  })();
}
function useGlobalCustomStickerer(puzzleStickering, m) {
  globalCustomStickerer(puzzleStickering, m);
}
if (globalThis.location && new URL(location.href).searchParams.get("global-custom-stickerer") === "true") {
  window.setGlobalCustomStickerer = setGlobalCustomStickerer;
  window.PieceStickering = PieceStickering;
  console.log("Global custom stickerer enabled! (using: global-custom-stickerer=true)");
  console.log("Look here for inspiration:", "https://github.com/cubing/cubing.js/blob/81b5cab3e27d8defb39dd1e0a10bc9e8ba894d26/src/cubing/puzzles/stickerings/cube-stickerings.ts#L67");
}

// src/cubing/puzzles/stickerings/cube-stickerings.ts
async function cubeAppearance(puzzleLoader, stickering) {
  const kpuzzle = await puzzleLoader.kpuzzle();
  const puzzleStickering = new PuzzleStickering(kpuzzle);
  const m = new StickeringManager(kpuzzle);
  const LL = () => m.move("U");
  const orUD = () => m.or(m.moves(["U", "D"]));
  const E = () => m.not(orUD());
  const orLR = () => m.or(m.moves(["L", "R"]));
  const M = () => m.not(orLR());
  const orFB = () => m.or(m.moves(["F", "B"]));
  const S = () => m.not(orFB());
  const F2L = () => m.not(LL());
  const centerU = () => m.and([LL(), M(), S()]);
  const edgeFR = () => m.and([m.and(m.moves(["F", "R"])), m.not(orUD())]);
  const cornerDFR = () => m.and(m.moves(["D", "R", "F"]));
  const slotFR = () => m.or([cornerDFR(), edgeFR()]);
  const CENTERS = () => m.or([m.and([M(), E()]), m.and([M(), S()]), m.and([E(), S()])]);
  const EDGES = () => m.or([
    m.and([M(), orUD(), orFB()]),
    m.and([E(), orLR(), orFB()]),
    m.and([S(), orUD(), orLR()])
  ]);
  const CORNERS = () => m.not(m.or([CENTERS(), EDGES()]));
  const L6E = () => m.or([M(), m.and([LL(), EDGES()])]);
  function dimF2L() {
    puzzleStickering.set(F2L(), "Dim" /* Dim */);
  }
  function setPLL() {
    puzzleStickering.set(LL(), "PermuteNonPrimary" /* PermuteNonPrimary */);
    puzzleStickering.set(centerU(), "Dim" /* Dim */);
  }
  function setOLL() {
    puzzleStickering.set(LL(), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
    puzzleStickering.set(centerU(), "Regular" /* Regular */);
  }
  function dimOLL() {
    puzzleStickering.set(LL(), "Ignoriented" /* Ignoriented */);
    puzzleStickering.set(centerU(), "Dim" /* Dim */);
  }
  switch (stickering) {
    case "full":
      break;
    case "PLL":
      dimF2L();
      setPLL();
      break;
    case "CLS":
      dimF2L();
      puzzleStickering.set(m.and(m.moves(["D", "R", "F"])), "Regular" /* Regular */);
      puzzleStickering.set(LL(), "Ignoriented" /* Ignoriented */);
      puzzleStickering.set(m.and([LL(), M(), S()]), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "OLL":
      dimF2L();
      setOLL();
      break;
    case "COLL":
      dimF2L();
      setPLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "OCLL":
      dimF2L();
      dimOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "CLL":
      dimF2L();
      puzzleStickering.set(m.not(m.and([CORNERS(), LL()])), "Dim" /* Dim */);
      break;
    case "ELL":
      dimF2L();
      puzzleStickering.set(LL(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), EDGES()]), "Regular" /* Regular */);
      break;
    case "ELS":
      dimF2L();
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored" /* Ignored */);
      puzzleStickering.set(edgeFR(), "Regular" /* Regular */);
      puzzleStickering.set(cornerDFR(), "Ignored" /* Ignored */);
      break;
    case "LL":
      dimF2L();
      break;
    case "F2L":
      puzzleStickering.set(LL(), "Ignored" /* Ignored */);
      break;
    case "ZBLL":
      dimF2L();
      puzzleStickering.set(LL(), "PermuteNonPrimary" /* PermuteNonPrimary */);
      puzzleStickering.set(centerU(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "ZBLS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored" /* Ignored */);
      break;
    case "WVLS":
    case "VLS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      setOLL();
      break;
    case "LS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      puzzleStickering.set(LL(), "Ignored" /* Ignored */);
      puzzleStickering.set(centerU(), "Dim" /* Dim */);
      break;
    case "EO":
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      break;
    case "EOline":
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.and(m.moves(["D", "M"])), "Regular" /* Regular */);
      break;
    case "EOcross":
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.move("D"), "Regular" /* Regular */);
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      break;
    case "CMLL":
      puzzleStickering.set(F2L(), "Dim" /* Dim */);
      puzzleStickering.set(L6E(), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "L6E":
      puzzleStickering.set(m.not(L6E()), "Dim" /* Dim */);
      break;
    case "L6EO":
      puzzleStickering.set(m.not(L6E()), "Dim" /* Dim */);
      puzzleStickering.set(L6E(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.and([CENTERS(), orUD()]), "OrientationStickers" /* OrientationStickers */);
      break;
    case "Daisy":
      puzzleStickering.set(m.all(), "Ignored" /* Ignored */);
      puzzleStickering.set(CENTERS(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("D"), CENTERS()]), "Regular" /* Regular */);
      puzzleStickering.set(m.and([m.move("U"), EDGES()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "Cross":
      puzzleStickering.set(m.all(), "Ignored" /* Ignored */);
      puzzleStickering.set(CENTERS(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("D"), CENTERS()]), "Regular" /* Regular */);
      puzzleStickering.set(m.and([m.move("D"), EDGES()]), "Regular" /* Regular */);
      break;
    case "2x2x2":
      puzzleStickering.set(m.or(m.moves(["U", "F", "R"])), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([m.or(m.moves(["U", "F", "R"])), CENTERS()]), "Dim" /* Dim */);
      break;
    case "2x2x3":
      puzzleStickering.set(m.all(), "Dim" /* Dim */);
      puzzleStickering.set(m.or(m.moves(["U", "F", "R"])), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([m.or(m.moves(["U", "F", "R"])), CENTERS()]), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("F"), m.not(m.or(m.moves(["U", "R"])))]), "Regular" /* Regular */);
      break;
    case "Void Cube":
      puzzleStickering.set(CENTERS(), "Invisible" /* Invisible */);
      break;
    case "picture":
    case "invisible":
      puzzleStickering.set(m.all(), "Invisible" /* Invisible */);
      break;
    case "centers-only":
      puzzleStickering.set(m.not(CENTERS()), "Ignored" /* Ignored */);
      break;
    case "experimental-global-custom-1":
    case "experimental-global-custom-2":
      useGlobalCustomStickerer(puzzleStickering, m);
      break;
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
      puzzleStickering.set(m.and(m.moves([])), "Dim" /* Dim */);
  }
  return puzzleStickering.toAppearance();
}
async function cubeStickerings() {
  return [
    "full",
    "PLL",
    "CLS",
    "OLL",
    "COLL",
    "OCLL",
    "ELL",
    "ELS",
    "LL",
    "F2L",
    "ZBLL",
    "ZBLS",
    "WVLS",
    "VLS",
    "LS",
    "EO",
    "EOline",
    "EOcross",
    "CMLL",
    "L6E",
    "L6EO",
    "Daisy",
    "Cross",
    "2x2x2",
    "2x2x3",
    "Void Cube",
    "picture",
    "invisible",
    "centers-only"
  ];
}

// src/cubing/puzzles/async/lazy-cached.ts
function getCached(getValue) {
  let cachedPromise = null;
  return () => {
    return cachedPromise ?? (cachedPromise = getValue());
  };
}

// src/cubing/puzzles/async/async-pg3d.ts
async function asyncGetPuzzleGeometry(puzzleName) {
  const puzzleGeometry = await import("./puzzle-geometry/index.js");
  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {
    allMoves: true,
    orientCenters: true,
    addRotations: true
  });
}
async function asyncGetKPuzzle2(pgPromise, puzzleName) {
  const pg = await pgPromise;
  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);
  kpuzzleDefinition.name = puzzleName;
  const puzzleGeometry = await import("./puzzle-geometry/index.js");
  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
  return new KPuzzle(kpuzzleDefinition, {
    experimentalPGNotation: pgNotation
  });
}
var _cachedPG, _cachedKPuzzle, _cachedSVG;
var PGPuzzleLoader = class {
  constructor(info) {
    __privateAdd(this, _cachedPG, void 0);
    __privateAdd(this, _cachedKPuzzle, void 0);
    __privateAdd(this, _cachedSVG, void 0);
    this.pgId = info.pgID;
    this.id = info.id;
    this.fullName = info.fullName;
    this.inventedBy = info.inventedBy;
    this.inventionYear = info.inventionYear;
  }
  pg() {
    return __privateGet(this, _cachedPG) ?? __privateSet(this, _cachedPG, asyncGetPuzzleGeometry(this.pgId ?? this.id));
  }
  kpuzzle() {
    return __privateGet(this, _cachedKPuzzle) ?? __privateSet(this, _cachedKPuzzle, asyncGetKPuzzle2(this.pg(), this.id));
  }
  svg() {
    return __privateGet(this, _cachedSVG) ?? __privateSet(this, _cachedSVG, (async () => (await this.pg()).generatesvg())());
  }
};
_cachedPG = new WeakMap();
_cachedKPuzzle = new WeakMap();
_cachedSVG = new WeakMap();
var CubePGPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super(...arguments);
    this.stickerings = cubeStickerings;
  }
  appearance(stickering) {
    return cubeAppearance(this, stickering);
  }
};

// src/cubing/puzzles/implementations/2x2x2/index.ts
var cube2x2x2 = {
  id: "2x2x2",
  fullName: "2\xD72\xD72 Cube",
  kpuzzle: getCached(async () => new KPuzzle((await import("./2x2x2.kpuzzle.json-BHTFIME6.js")).cube2x2x2KPuzzleDefinition)),
  svg: async () => {
    return (await import("./2x2x2.kpuzzle.svg-CYX37VBY.js")).default;
  },
  pg: getCached(async () => {
    return asyncGetPuzzleGeometry("2x2x2");
  }),
  appearance: (stickering) => cubeAppearance(cube2x2x2, stickering),
  stickerings: cubeStickerings
};

// src/cubing/puzzles/implementations/3x3x3/index.ts
var cube3x3x3 = {
  id: "3x3x3",
  fullName: "3\xD73\xD73 Cube",
  inventedBy: ["Ern\u0151 Rubik"],
  inventionYear: 1974,
  kpuzzle: getCached(async () => {
    return experimental3x3x3KPuzzle;
  }),
  svg: getCached(async () => {
    return (await import("./3x3x3.kpuzzle.svg-5U7LUACF.js")).default;
  }),
  llSVG: getCached(async () => {
    return (await import("./3x3x3-ll.kpuzzle.svg-KZNSV76X.js")).default;
  }),
  pg: getCached(async () => {
    return asyncGetPuzzleGeometry("3x3x3");
  }),
  appearance: (stickering) => cubeAppearance(cube3x3x3, stickering),
  stickerings: cubeStickerings
};

// src/cubing/puzzles/implementations/clock/index.ts
var clock = {
  id: "clock",
  fullName: "Clock",
  inventedBy: ["Christopher C. Wiggs", "Christopher J. Taylor"],
  inventionYear: 1988,
  kpuzzle: getCached(async () => new KPuzzle((await import("./clock.kpuzzle.json-PYHONPBY.js")).clockKPuzzleDefinition)),
  svg: getCached(async () => {
    return (await import("./clock.kpuzzle.svg-JSRDCSQF.js")).default;
  })
};

// src/cubing/puzzles/stickerings/fto-stickerings.ts
async function ftoStickering(puzzleLoader, stickering) {
  const kpuzzle = await puzzleLoader.kpuzzle();
  const puzzleStickering = new PuzzleStickering(kpuzzle);
  const m = new StickeringManager(kpuzzle);
  const experimentalFTO_FC = () => m.and([m.move("U"), m.not(m.or(m.moves(["F", "BL", "BR"])))]);
  const experimentalFTO_F2T = () => m.and([m.move("U"), m.not(m.move("F"))]);
  const experimentalFTO_SC = () => m.or([
    experimentalFTO_F2T(),
    m.and([m.move("F"), m.not(m.or(m.moves(["U", "BL", "BR"])))])
  ]);
  const experimentalFTO_L2C = () => m.not(m.or([
    m.and([m.move("U"), m.move("F")]),
    m.and([m.move("F"), m.move("BL")]),
    m.and([m.move("F"), m.move("BR")]),
    m.and([m.move("BL"), m.move("BR")])
  ]));
  const experimentalFTO_LBT = () => m.not(m.or([
    m.and([m.move("F"), m.move("BL")]),
    m.and([m.move("F"), m.move("BR")]),
    m.and([m.move("BL"), m.move("BR")])
  ]));
  switch (stickering) {
    case "full":
      break;
    case "experimental-fto-fc":
      puzzleStickering.set(m.not(experimentalFTO_FC()), "Ignored" /* Ignored */);
      break;
    case "experimental-fto-f2t":
      puzzleStickering.set(m.not(experimentalFTO_F2T()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_FC(), "Dim" /* Dim */);
      break;
    case "experimental-fto-sc":
      puzzleStickering.set(m.not(experimentalFTO_SC()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_F2T(), "Dim" /* Dim */);
      break;
    case "experimental-fto-l2c":
      puzzleStickering.set(m.not(experimentalFTO_L2C()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_SC(), "Dim" /* Dim */);
      break;
    case "experimental-fto-lbt":
      puzzleStickering.set(m.not(experimentalFTO_LBT()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_L2C(), "Dim" /* Dim */);
      break;
    case "experimental-fto-l3t":
      puzzleStickering.set(experimentalFTO_LBT(), "Dim" /* Dim */);
      break;
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
      puzzleStickering.set(m.and(m.moves([])), "Dim" /* Dim */);
  }
  return puzzleStickering.toAppearance();
}
async function ftoStickerings() {
  return [
    "full",
    "experimental-fto-fc",
    "experimental-fto-f2t",
    "experimental-fto-sc",
    "experimental-fto-l2c",
    "experimental-fto-lbt",
    "experimental-fto-l3t"
  ];
}

// src/cubing/puzzles/implementations/fto/index.ts
var FTOPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      pgID: "FTO",
      id: "fto",
      fullName: "Face-Turning Octahedron",
      inventedBy: ["Karl Rohrbach", "David Pitcher"],
      inventionYear: 1983
    });
    this.stickerings = ftoStickerings;
    this.svg = getCached(async () => {
      return (await import("./fto.kpuzzle.svg-H2RJX6UR.js")).ftoSVG;
    });
  }
  appearance(stickering) {
    return ftoStickering(this, stickering);
  }
};
var fto = new FTOPuzzleLoader();

// src/cubing/puzzles/stickerings/megaminx-stickerings.ts
async function megaminxAppearance(puzzleLoader, stickering) {
  switch (stickering) {
    case "full":
    case "F2L":
    case "LL":
      return cubeAppearance(puzzleLoader, stickering);
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
  }
  return cubeAppearance(puzzleLoader, "full");
}
async function megaminxStickerings() {
  return ["full", "F2L", "LL"];
}

// src/cubing/puzzles/implementations/megaminx/index.ts
var MegaminxPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      id: "megaminx",
      fullName: "Megaminx",
      inventionYear: 1981
    });
    this.stickerings = megaminxStickerings;
  }
  appearance(stickering) {
    return megaminxAppearance(this, stickering);
  }
};
var megaminx = new MegaminxPuzzleLoader();

// src/cubing/puzzles/implementations/pyraminx/index.ts
var PyraminxPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      id: "pyraminx",
      fullName: "Pyraminx",
      inventedBy: ["Uwe Meffert"]
    });
    this.svg = getCached(async () => {
      return (await import("./pyraminx.kpuzzle.svg-UHDZCBET.js")).default;
    });
  }
};
var pyraminx = new PyraminxPuzzleLoader();

// src/cubing/puzzles/implementations/square1/index.ts
var square1 = {
  id: "square1",
  fullName: "Square-1",
  inventedBy: ["Karel Hr\u0161el", "Vojtech Kopsk\xFD"],
  inventionYear: 1990,
  kpuzzle: getCached(async () => new KPuzzle((await import("./sq1-hyperorbit.kpuzzle.json-AMXAFQCM.js")).sq1HyperOrbitKPuzzleDefinition)),
  svg: getCached(async () => {
    return (await import("./sq1-hyperorbit.kpuzzle.svg-MNHJTJ6V.js")).default;
  })
};

// src/cubing/puzzles/implementations/kilominx/index.ts
var kilominx = {
  id: "kilominx",
  fullName: "Kilominx",
  kpuzzle: getCached(async () => {
    const pg = await asyncGetPuzzleGeometry("megaminx + chopasaurus");
    const kpuzzleDefinition = JSON.parse(JSON.stringify(pg.getKPuzzleDefinition(true)));
    delete kpuzzleDefinition.orbits.CENTERS;
    delete kpuzzleDefinition.orbits.CENTERS2;
    delete kpuzzleDefinition.startStateData.CENTERS;
    delete kpuzzleDefinition.startStateData.CENTERS2;
    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {
      delete moveDefinition.CENTERS;
      delete moveDefinition.CENTERS2;
    }
    kpuzzleDefinition.name = "kilominx";
    delete kpuzzleDefinition.experimentalPuzzleDescription;
    const puzzleGeometry = await import("./puzzle-geometry/index.js");
    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
    const kpuzzle = new KPuzzle(kpuzzleDefinition, {
      experimentalPGNotation: {
        lookupMove: (move) => {
          if (move.toString() === "x2" || move.toString() === "x2'") {
            return x2Transformation.transformationData;
          }
          return pgNotation.lookupMove(move);
        }
      }
    });
    const x2Transformation = kpuzzle.algToTransformation("Rv2 Fv Uv'");
    kpuzzleDefinition.moves["x2"] = x2Transformation;
    return kpuzzle;
  }),
  svg: getCached(async () => {
    return (await import("./kilominx.kpuzzle.svg-ZLRTRUTM.js")).kilominxSVG;
  })
};

// src/cubing/puzzles/implementations/redi-cube/index.ts
var rediCube = {
  id: "redi_cube",
  fullName: "Redi Cube",
  inventedBy: ["Oskar van Deventer"],
  inventionYear: 2009,
  kpuzzle: getCached(async () => new KPuzzle((await import("./redi_cube.kpuzzle.json-43CP47Z6.js")).rediCubeKPuzzleDefinition)),
  svg: async () => {
    return (await import("./redi_cube.kpuzzle.svg-3DWDYE3O.js")).rediCubeSVG;
  }
};

// src/cubing/puzzles/index.ts
var puzzles = {
  "3x3x3": cube3x3x3,
  "2x2x2": cube2x2x2,
  "4x4x4": new CubePGPuzzleLoader({ id: "4x4x4", fullName: "4\xD74\xD74 Cube" }),
  "5x5x5": new CubePGPuzzleLoader({ id: "5x5x5", fullName: "5\xD75\xD75 Cube" }),
  "6x6x6": new CubePGPuzzleLoader({ id: "6x6x6", fullName: "6\xD76\xD76 Cube" }),
  "7x7x7": new CubePGPuzzleLoader({ id: "7x7x7", fullName: "7\xD77\xD77 Cube" }),
  "40x40x40": new CubePGPuzzleLoader({
    id: "40x40x40",
    fullName: "40\xD740\xD740 Cube"
  }),
  clock,
  "megaminx": megaminx,
  pyraminx,
  "skewb": new PGPuzzleLoader({
    id: "skewb",
    fullName: "Skewb",
    inventedBy: ["Tony Durham"]
  }),
  square1,
  "fto": fto,
  "gigaminx": new PGPuzzleLoader({
    id: "gigaminx",
    fullName: "Gigaminx",
    inventedBy: ["Tyler Fox"],
    inventionYear: 2006
  }),
  "master_tetraminx": new PGPuzzleLoader({
    pgID: "master tetraminx",
    id: "master_tetraminx",
    fullName: "Master Tetraminx",
    inventedBy: ["Katsuhiko Okamoto"],
    inventionYear: 2002
  }),
  kilominx,
  "redi_cube": rediCube
};

export {
  customPGPuzzleLoader,
  wcaEventInfo,
  eventInfo,
  getFaceletAppearance,
  cubeAppearance,
  cube2x2x2,
  cube3x3x3,
  puzzles
};
//# sourceMappingURL=chunk-QYQUT5N5.js.map
