{
  "version": 3,
  "sources": ["../../src/cubing/vendor/xyzzy/redi_cube.js"],
  "sourcesContent": ["/* eslint-disable */\n/* Redi cube scramble generator */\n// From https://torchlight.github.io/rediscrambler.js\n// Added to `cubing.js` under the GPL license by permission from the author (@torchlight/xyzzy).\n\n\"use strict\";\n\nimport { Alg } from \"../../alg\";\nimport { randomUIntBelowFactory } from \"../random-uint-below\";\n\nfunction counter(A) {\n  let counts = [];\n  for (let a of A) counts[a] = (counts[a] || 0) + 1;\n  return counts;\n}\n\n/* Combinatoric functions */\n\nfunction factorial(n) {\n  if (n < 2) return n;\n  let f = 1;\n  for (let i = 2; i <= n; i++) f *= i;\n  return f;\n}\n\nfunction C(n, k) {\n  if (k < 0 || k > n) return 0;\n  if (k === 0 || k === n) return 1;\n  let c = 1;\n  for (let i = 0; i < k; i++) {\n    c = ((c * (n - i)) / (i + 1)) | 0;\n  }\n  return c;\n}\n\nfunction permutation_to_index(perm) {\n  perm = perm.slice();\n  let n = perm.length;\n  let f = factorial(n - 1);\n  let ind = 0;\n  while (n > 1) {\n    n--;\n    // invariant: f == factorial(n)\n    // also, perm stores meaningful values up to perm[n]\n    let e = perm[0];\n    ind += e * f;\n    for (let i = 0; i < n; i++) {\n      let x = perm[i + 1];\n      perm[i] = x - (x > e);\n    }\n    f /= n;\n  }\n  return ind;\n}\n\nfunction index_to_permutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1);\n  for (let i = 0; i < n; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  // could probably use some kind of binary tree to make this linearithmic, but I am hella lazy.\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      perm[j] += +(perm[j] >= perm[i]);\n    }\n  }\n  return perm;\n}\n\nfunction permutation_parity(A) {\n  let n = A.length;\n  let parity = 0;\n  // again, there is a linearithmic algorithm to count inversions, but >lazy\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i; j < n; j++) {\n      if (A[i] > A[j]) parity ^= 1;\n    }\n  }\n  return parity;\n}\n\nfunction index_to_evenpermutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1) / 2;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  perm[n - 1] = 0;\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      if (perm[j] >= perm[i]) perm[j]++;\n      else parity ^= 1;\n    }\n  }\n  if (parity === 1) [perm[n - 2], perm[n - 1]] = [perm[n - 1], perm[n - 2]];\n  return perm;\n}\n\nfunction evenpermutation_to_index(perm) {\n  return permutation_to_index(perm) >> 1;\n}\n\nfunction comb_to_index(l) {\n  let bits = l.length;\n  let ones = 0;\n  for (let i = 0; i < bits; i++) ones += +(l[i] === 1);\n  let zeros = bits - ones;\n  if (zeros === 0 || ones === 0 || bits === 1) return 0;\n  let b = C(bits - 1, ones);\n  let ind = 0;\n  for (let i = 0; zeros > 0 && ones > 0 && bits > 1; i++) {\n    bits--;\n    if (l[i] === 0) {\n      b = (b * --zeros) / bits;\n    } // l[i] === 1\n    else {\n      ind += b;\n      b = (b * ones--) / bits;\n    }\n  }\n  return ind;\n}\n\nfunction index_to_comb(ind, ones, bits) {\n  let zeros = bits - ones;\n  let b = C(bits - 1, ones);\n  let l = [];\n  let n = bits - 1;\n  for (let i = 0; i < n; i++) {\n    bits--;\n    if (ind < b) {\n      l.push(0);\n      b = (b * --zeros) / bits;\n    } else {\n      l.push(1);\n      ind -= b;\n      b = (b * ones--) / bits;\n    }\n  }\n  l.push(ones);\n  return l;\n}\n\nfunction compose(A, B) {\n  let C = [];\n  for (let i = 0; i < B.length; i++) C[i] = A[B[i]];\n  return C;\n}\n\nfunction permutation_from_cycle(cycle, n) {\n  let perm = [];\n  for (let i = 0; i < n; i++) perm[i] = i;\n  for (let i = 0; i < cycle.length; i++) {\n    perm[cycle[i]] = cycle[(i + 1) % cycle.length];\n  }\n  return perm;\n}\n\nfunction unsparsify_list(d, n) {\n  let l = Array(n).fill(0);\n  for (let k in d) l[k] = d[k];\n  return l;\n}\n\nfunction compose_state(state1, state2) {\n  let o = Array(8).fill(0);\n  for (let i = 0; i < 8; i++) o[i] = (state1[1][i] + state2[1][i]) % 3;\n  return [compose(state1[0], state2[0]), o];\n}\n\nlet move_UL = [\n  permutation_from_cycle([0, 1, 4], 12),\n  unsparsify_list({ 0: 2 }, 8),\n];\nlet move_U = [\n  permutation_from_cycle([1, 2, 5], 12),\n  unsparsify_list({ 1: 2 }, 8),\n];\nlet move_UR = [\n  permutation_from_cycle([2, 3, 6], 12),\n  unsparsify_list({ 2: 2 }, 8),\n];\nlet move_F = [\n  permutation_from_cycle([3, 0, 7], 12),\n  unsparsify_list({ 3: 2 }, 8),\n];\nlet move_L = [\n  permutation_from_cycle([9, 8, 4], 12),\n  unsparsify_list({ 4: 2 }, 8),\n];\nlet move_B = [\n  permutation_from_cycle([10, 9, 5], 12),\n  unsparsify_list({ 5: 2 }, 8),\n];\nlet move_R = [\n  permutation_from_cycle([11, 10, 6], 12),\n  unsparsify_list({ 6: 2 }, 8),\n];\nlet move_D = [\n  permutation_from_cycle([8, 11, 7], 12),\n  unsparsify_list({ 7: 2 }, 8),\n];\n\nlet solved = [index_to_permutation(0, 12), Array(8).fill(0)];\n\nlet moves = [move_UL, move_U, move_UR, move_F, move_L, move_B, move_R, move_D];\nlet move_names = [\"UL\", \"U\", \"UR\", \"F\", \"L\", \"B\", \"R\", \"D\"];\nlet tetrad = [0, 1, 0, 1, 1, 0, 1, 0];\n\nfunction apply_move_sequence(state, move_sequence) {\n  for (let [m, r] of move_sequence) {\n    for (let i = 0; i < r; i++) state = compose_state(state, moves[m]);\n  }\n  return state;\n}\n\nfunction stringify_move_sequence(move_sequence) {\n  let suffixes = [\"0\", \"\", \"'\"];\n  let s = move_sequence.map(([m, r]) => move_names[m] + suffixes[r]);\n  return s.join(\" \");\n}\n\nfunction print_move_sequence(move_sequence) {\n  console.log(stringify_move_sequence(move_sequence));\n}\n\nfunction generate_random_state(randomUintBelow) {\n  let p = index_to_evenpermutation(\n    Math.floor(randomUintBelow(factorial(12)) / 2),\n    12,\n  );\n  let o = Array(8);\n  for (let i = 0; i < 8; i++) o[i] = randomUintBelow(3);\n  return [p, o];\n}\n\nfunction generate_random_state_scramble(randomUintBelow) {\n  return solve(generate_random_state(randomUintBelow));\n}\n\nfunction generate_scramble_sequence() {\n  return stringify_move_sequence(generate_random_state_scramble());\n}\n\nfunction solve(state) {\n  let phase1_indices = index_phase1(state);\n  let phase1_mtables = [\n    generate_phase1_edge_mtable(),\n    generate_phase1_separate_mtable(),\n  ];\n  let phase1_ptables = [\n    generate_phase1_edge_ptable(),\n    generate_phase1_separate_ptable(),\n  ];\n  let phase2_mtables = [\n    generate_phase2_edge_mtable(),\n    generate_phase2_corner_mtable(),\n  ];\n  let phase2_ptables = [\n    generate_phase2_edge_ptable(),\n    generate_phase1_corner_ptable(),\n  ];\n\n  let phase1gen = ida_solve_gen(phase1_indices, phase1_mtables, phase1_ptables);\n  let best = undefined;\n  let intermediate_states = new Set();\n  let start_time = +new Date();\n  for (let i = 0; i < 25; i++) {\n    let { value: sol1, done } = phase1gen.next();\n    let new_state = state;\n    for (let [m, r] of sol1) {\n      for (let i = 0; i < r; i++)\n        new_state = compose_state(new_state, moves[m]);\n    }\n    if (intermediate_states.has(new_state.toString())) {\n      // console.log(\"skip\");\n      continue;\n    } else intermediate_states.add(new_state.toString());\n    let edge_ind = evenpermutation_to_index(new_state[0].slice(0, 8));\n    let corner_ind = 0;\n    for (let i = 0; i < 4; i++) corner_ind += new_state[1][i] * 3 ** i;\n    let phase2_indices = [edge_ind, corner_ind];\n    //let sol2 = [];\n    let moves_left = best ? best.length - sol1.length - 1 : 999999;\n    let sol2 = ida_solve(\n      phase2_indices,\n      phase2_mtables,\n      phase2_ptables,\n      moves_left,\n    );\n    if (sol2 === undefined) {\n      // console.log(\"prune\");\n      continue;\n    }\n    // console.log(\n    //   `to ${new_state} in ${sol1.length} moves; total move count ${\n    //     sol1.length + sol2.length\n    //   }`,\n    // );\n    if (best === undefined || best.length > sol1.length + sol2.length) {\n      best = sol1.concat(sol2);\n    }\n    // bail if we've spent too much time\n    if (new Date() - start_time > 300) break;\n  }\n  return best;\n}\n\nfunction index_phase1(state) {\n  let edge_ind = 0;\n  for (let i = 0; i < 4; i++) edge_ind += state[0].indexOf(i + 8) * 12 ** i;\n  let corner_ind = 0;\n  for (let i = 0; i < 4; i++) corner_ind += state[1][i + 4] * 3 ** i;\n  let filtered = state[0].map((x) => Math.max(-1, x - 8));\n  let separate_ind =\n    comb_to_index(filtered.map((x) => +(x >= 0))) * 2 +\n    permutation_parity(filtered.filter((x) => x >= 0));\n  return [edge_ind, corner_ind + 81 * separate_ind];\n}\n\nlet tables = {};\n\nfunction generate_phase1_corner_mtable() {\n  if (tables.phase1cm) return tables.phase1cm;\n  let mtable = [];\n  for (let i = 0; i < 81; i++) {\n    mtable[i] = Array(8);\n    let o = [\n      i % 3,\n      Math.floor(i / 3) % 3,\n      Math.floor(i / 9) % 3,\n      Math.floor(i / 27),\n    ];\n    mtable[i][0] = mtable[i][1] = mtable[i][2] = mtable[i][3] = i;\n    for (let j = 0; j < 4; j++) {\n      o[j] = (o[j] + 2) % 3;\n      mtable[i][4 + j] = o[0] + o[1] * 3 + o[2] * 9 + o[3] * 27;\n      o[j] = (o[j] + 1) % 3;\n    }\n  }\n  return (tables.phase1cm = mtable);\n}\n\nfunction generate_phase1_corner_ptable() {\n  if (tables.phase1cp) return tables.phase1cp;\n  let ptable = Array(81);\n  for (let i = 0; i < 81; i++) {\n    let o = [\n      i % 3,\n      Math.floor(i / 3) % 3,\n      Math.floor(i / 9) % 3,\n      Math.floor(i / 27),\n    ];\n    ptable[i] = (o[0] !== 0) + (o[1] !== 0) + (o[2] !== 0) + (o[3] !== 0);\n  }\n  return (tables.phase1cp = ptable);\n}\n\nfunction generate_phase1_edge_mtable() {\n  if (tables.phase1em) return tables.phase1em;\n  let mtable_single = [];\n  for (let i = 0; i < 12; i++) {\n    mtable_single[i] = [];\n    for (let m = 0; m < 8; m++) {\n      mtable_single[i][m] = moves[m][0].indexOf(i);\n    }\n  }\n  let mtable = Array(12 ** 4);\n  for (let i = 0; i < 12 ** 4; i++) {\n    mtable[i] = Array(8);\n    for (let m = 0; m < 8; m++) {\n      let I = 0;\n      for (let j = 0; j < 4; j++) {\n        I += mtable_single[Math.floor(i / 12 ** j) % 12][m] * 12 ** j;\n      }\n      mtable[i][m] = I;\n    }\n  }\n  return (tables.phase1em = mtable);\n}\n\nfunction generate_phase1_edge_ptable() {\n  if (tables.phase1ep) return tables.phase1ep;\n  return (tables.phase1ep = bfs(generate_phase1_edge_mtable(), [\n    8 + 12 * (9 + 12 * (10 + 12 * 11)),\n  ]));\n}\n\nfunction generate_phase1_separate_mtable() {\n  if (tables.phase1sm) return tables.phase1sm;\n  const C12_4 = C(12, 4);\n  let mtable_c = [];\n  for (let i = 0; i < C12_4; i++) {\n    mtable_c[i] = [];\n    let comb = index_to_comb(i, 4, 12),\n      perm = [];\n    for (let j = 0, k = 0; j < 12; j++) {\n      if (comb[j] === 0) perm[j] = -1;\n      else perm[j] = k++;\n    }\n    for (let m = 0; m < 8; m++) {\n      let new_perm = compose(perm, moves[m][0]);\n      let new_comb = compose(comb, moves[m][0]);\n      let parity = permutation_parity(new_perm.filter((x) => x >= 0));\n      mtable_c[i][m] = comb_to_index(new_comb) * 2 + parity;\n    }\n  }\n  let mtable_co = generate_phase1_corner_mtable();\n  let mtable = [];\n  for (let j = 0; j < C12_4; j++) {\n    for (let i = 0; i < 81; i++) {\n      let m0 = (mtable[i + 81 * (2 * j)] = []);\n      let m1 = (mtable[i + 81 * (2 * j + 1)] = []);\n      for (let m = 0; m < 8; m++) {\n        m0[m] = mtable_co[i][m] + 81 * mtable_c[j][m];\n        m1[m] = mtable_co[i][m] + 81 * (mtable_c[j][m] ^ 1);\n      }\n    }\n  }\n  return (tables.phase1sm = mtable);\n}\n\nfunction generate_phase1_separate_ptable() {\n  if (tables.phase1sp) return tables.phase1sp;\n  return (tables.phase1sp = bfs(generate_phase1_separate_mtable(), [0]));\n}\n\nfunction generate_phase2_corner_mtable() {\n  if (tables.phase2cm) return tables.phase2cm;\n  let phase1_mtable = generate_phase1_corner_mtable();\n  let mtable = Array(81);\n  for (let i = 0; i < 81; i++) {\n    mtable[i] = phase1_mtable[i].slice(4, 8);\n  }\n  return (tables.phase2cm = mtable);\n}\n\nfunction generate_phase2_edge_mtable() {\n  if (tables.phase2em) return tables.phase2em;\n  const n = 8;\n  const HALFFACT8 = factorial(n) / 2;\n  let mtable = Array(HALFFACT8);\n  let perm = [0, 1, 2, 3, 4, 5, 6, 7];\n  for (let i = 0; i < HALFFACT8; i++) {\n    //perm = index_to_evenpermutation(i, 8);\n    mtable[i] = Array(4);\n    for (let m = 0; m < 4; m++) {\n      let new_perm = compose(perm, moves[m][0].slice(0, 8));\n      mtable[i][m] = evenpermutation_to_index(new_perm);\n    }\n\n    if (i === HALFFACT8 - 1) break;\n    // update perm to lex-next even permutation\n    let parity = 0;\n    do {\n      for (let k = n - 2; k >= 0; k--) {\n        if (perm[k] > perm[k + 1]) continue;\n        let l = k + 1;\n        for (let L = l; L < n; L++) if (perm[L] > perm[k]) l = L;\n        [perm[k], perm[l]] = [perm[l], perm[k]];\n        parity ^= 1;\n        for (let j = 0; k + 1 + j < n - 1 - j; j++, parity ^= 1) {\n          [perm[k + 1 + j], perm[n - 1 - j]] = [\n            perm[n - 1 - j],\n            perm[k + 1 + j],\n          ];\n        }\n        break;\n      }\n    } while (parity !== 0);\n  }\n  return (tables.phase2em = mtable);\n}\n\nfunction generate_phase2_edge_ptable() {\n  if (tables.phase2ep) return tables.phase2ep;\n  return (tables.phase2ep = bfs(generate_phase2_edge_mtable(), [0]));\n}\n\nfunction bfs(mtable, goal_states) {\n  let N = mtable.length;\n  let nmoves = mtable[0].length;\n  let ptable = Array(N).fill(-1);\n  let queue = goal_states.slice(),\n    new_queue = [];\n  let depth = 0;\n  while (queue.length > 0) {\n    new_queue.length = 0;\n    for (let state of queue) {\n      if (ptable[state] !== -1) continue;\n      ptable[state] = depth;\n      for (let move_index = 0; move_index < nmoves; move_index++) {\n        let new_state = mtable[state][move_index];\n        while (new_state != state) {\n          new_queue.push(new_state);\n          new_state = mtable[new_state][move_index];\n        }\n      }\n    }\n    [queue, new_queue] = [new_queue, queue];\n    depth += 1;\n  }\n  return ptable;\n}\n\nfunction ida_solve(indices, mtables, ptables, max_bound) {\n  max_bound = max_bound || 999999;\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (bound <= max_bound) {\n    let path = ida_search(indices, mtables, ptables, bound, -1);\n    if (path !== undefined) return path;\n    bound++;\n  }\n}\n\nfunction ida_search(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound) return;\n  if (bound === 0) return [];\n  if (heuristic === 0 && bound === 1) return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    if (m < last && tetrad[m] == tetrad[last]) continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath = ida_search(new_indices, mtables, ptables, bound - 1, m);\n      if (subpath !== undefined) return [[m, r]].concat(subpath);\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n  return;\n}\n\nfunction* ida_solve_gen(indices, mtables, ptables) {\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (true) {\n    yield* ida_search_gen(indices, mtables, ptables, bound, -1);\n    bound++;\n  }\n}\n\nfunction* ida_search_gen(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound) return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1) return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    if (m < last && tetrad[m] == tetrad[last]) continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath_gen = ida_search_gen(\n        new_indices,\n        mtables,\n        ptables,\n        bound - 1,\n        m,\n      );\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done) break;\n        yield [[m, r]].concat(subpath);\n      }\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n}\n\nconst randomUintBelow = randomUIntBelowFactory();\nexport async function getRandomRediCubeScramble() {\n  return new Alg(\n    stringify_move_sequence(\n      generate_random_state_scramble(await randomUintBelow),\n    ),\n  );\n}\n"],
  "mappings": "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",
  "names": []
}
