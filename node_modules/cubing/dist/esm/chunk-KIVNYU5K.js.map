{
  "version": 3,
  "sources": ["../../src/cubing/vendor/p-lazy/p-lazy.ts", "../../src/cubing/twisty/model/PromiseFreshener.ts", "../../src/cubing/twisty/model/props/TwistyProp.ts", "../../src/cubing/twisty/model/props/puzzle/display/StickeringProp.ts", "../../src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts", "../../src/cubing/twisty/views/3D/TAU.ts", "../../src/cubing/twisty/heavy-code-imports/3d.ts"],
  "sourcesContent": ["// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\n// TODO: Use private class fields when ESLint support it.\n\nexport class PLazy<T> extends Promise<T> {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n\n    this._executor = executor;\n  }\n\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this._promise.catch(onRejected);\n  }\n}\n\nexport function from<T>(function_): Promise<T> {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n", "// TODO: Pick a much better name.\nexport class PromiseFreshener<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  // TODO: reject instead? Drop?\n  async queue(\n    p: Promise<T>,\n  ): Promise<{ fresh: false } | { fresh: true; result: T }> {\n    const idx = ++this.#latestAssignedIdx;\n    const result = await p;\n    if (idx > this.#latestResolvedIdx) {\n      this.#latestResolvedIdx = idx;\n      return {\n        fresh: true,\n        result: result,\n      };\n    } else {\n      return { fresh: false };\n    }\n  }\n}\n\n// This will silenty drop a queued Promise (i.e. not resolve it) if a\n// newer queued one already resolved first. This is useful for classes that want\n// to know the \"latest\" state of something without jumping back to an older\n// value by accident.\n// TODO: Remove this because it's too easy to misuse?\nexport class StaleDropper<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  queue(p: Promise<T>): Promise<T> {\n    // This is a very rare case where we *do* want to drop a Promise sometimes.\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      try {\n        const idx = ++this.#latestAssignedIdx;\n        const result = await p;\n        if (idx > this.#latestResolvedIdx) {\n          this.#latestResolvedIdx = idx;\n          resolve(result);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n}\n", "import { from } from \"../../../vendor/p-lazy/p-lazy\";\nimport { StaleDropper } from \"../PromiseFreshener\";\nimport type { UserVisibleErrorTracker } from \"../UserVisibleErrorTracker\";\n\n/*eslint @typescript-eslint/ban-types:off */\ntype InputRecord = {};\n\nexport type InputProps<T extends InputRecord> = {\n  [s in keyof T]: TwistyPropParent<T[s]>;\n};\n\ntype InputPromises<T extends InputRecord> = {\n  [s in keyof T]: Promise<T[s]>;\n};\n\ninterface SourceEventDetail<OutputType> {\n  sourceProp: TwistyPropSource<OutputType, any>;\n  value: Promise<OutputType>; // TODO: remove?\n  generation: number;\n}\n\ntype SourceEvent<T> = CustomEvent<SourceEventDetail<T>>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\n// Values of T must be immutable.\nlet globalSourceGeneration = 0; // This is incremented before being used, so 1 will be the first active value.\nexport abstract class TwistyPropParent<T> {\n  public abstract get(): Promise<T>;\n\n  // Don't overwrite this. Overwrite `canReuseValue` instead.\n  canReuse(v1: T, v2: T): boolean {\n    return v1 === v2 || this.canReuseValue(v1, v2);\n  }\n\n  // Overwrite with a cheap semantic comparison when possible.\n  // Note that this is not called if `v1 === v2` (in which case the value is automatically reused).\n  canReuseValue(_v1: T, _v2: T): boolean {\n    return false;\n  }\n\n  debugGetChildren(): Array<TwistyPropDerived<any, any>> {\n    return Array.from(this.#children.values());\n  }\n\n  // Propagation\n\n  #children: Set<TwistyPropDerived<any, any>> = new Set();\n  protected addChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.add(child);\n  }\n\n  protected removeChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.delete(child);\n  }\n\n  protected lastSourceGeneration: number = 0;\n  // Synchronously marks all descendants as stale. This doesn't actually\n  // literally mark as stale, but it updates the last source generation, which\n  // is used to tell if a cahced result is stale.\n  protected markStale(sourceEvent: SourceEvent<any>): void {\n    if (sourceEvent.detail.generation !== globalSourceGeneration) {\n      // The full stale propagation is synchronous, so there should not be a new one yet.\n      throw new Error(\"A TwistyProp was marked stale too late!\");\n    }\n    if (this.lastSourceGeneration === sourceEvent.detail.generation) {\n      // Already propagated.\n      return;\n    }\n    this.lastSourceGeneration = sourceEvent.detail.generation;\n    for (const child of this.#children) {\n      child.markStale(sourceEvent);\n    }\n    // We schedule sending out events *after* the (synchronous) propagation has happened, in\n    // case one of the listeners updates a source again.\n    this.#scheduleRawDispatch();\n  }\n\n  #rawListeners: Set<() => void> = new Set();\n  /** @deprecated */\n  addRawListener(listener: () => void, options?: { initial: boolean }): void {\n    this.#rawListeners.add(listener);\n    if (options?.initial) {\n      listener(); // TODO: wrap in a try?\n    }\n  }\n\n  /** @deprecated */\n  removeRawListener(listener: () => void): void {\n    this.#rawListeners.delete(listener);\n  }\n\n  /** @deprecated */\n  #scheduleRawDispatch(): void {\n    if (!this.#rawDispatchPending) {\n      this.#rawDispatchPending = true;\n      setTimeout(() => this.#dispatchRawListeners(), 0);\n    }\n  }\n\n  #rawDispatchPending: boolean = false;\n  #dispatchRawListeners(): void {\n    if (!this.#rawDispatchPending) {\n      throw new Error(\"Invalid dispatch state!\");\n    }\n    for (const listener of this.#rawListeners) {\n      listener(); // TODO: wrap in a try?\n    }\n    this.#rawDispatchPending = false;\n  }\n\n  #freshListeners: Map<(value: T) => void, () => void> = new Map();\n  // TODO: Pick a better name.\n  addFreshListener(listener: (value: T) => void): void {\n    const staleDropper: StaleDropper<T> = new StaleDropper<T>();\n    let lastResult: T | null = null;\n    const callback = async () => {\n      const result = await staleDropper.queue(this.get());\n      if (lastResult !== null && this.canReuse(lastResult, result)) {\n        return;\n      }\n      lastResult = result;\n      listener(result);\n    };\n    this.#freshListeners.set(listener, callback);\n    this.addRawListener(callback, { initial: true });\n  }\n\n  removeFreshListener(listener: (value: T) => void): void {\n    this.removeRawListener(this.#freshListeners.get(listener)!); // TODO: throw a custom error?\n    this.#freshListeners.delete(listener);\n  }\n}\n\nexport abstract class TwistyPropSource<\n  OutputType,\n  InputType = OutputType,\n> extends TwistyPropParent<OutputType> {\n  #value: Promise<OutputType>;\n\n  public abstract getDefaultValue(): PromiseOrValue<OutputType>;\n\n  constructor(initialValue?: PromiseOrValue<InputType>) {\n    super();\n    this.#value = from(() => this.getDefaultValue());\n    if (initialValue) {\n      this.#value = this.deriveFromPromiseOrValue(initialValue, this.#value);\n    }\n  }\n\n  set(input: PromiseOrValue<InputType>): void {\n    this.#value = this.deriveFromPromiseOrValue(input, this.#value);\n\n    const sourceEventDetail: SourceEventDetail<OutputType> = {\n      sourceProp: this,\n      value: this.#value,\n      generation: ++globalSourceGeneration,\n    };\n    this.markStale(\n      new CustomEvent<SourceEventDetail<OutputType>>(\"stale\", {\n        detail: sourceEventDetail,\n      }),\n    );\n  }\n\n  async get(): Promise<OutputType> {\n    return this.#value;\n  }\n\n  async deriveFromPromiseOrValue(\n    input: PromiseOrValue<InputType>,\n    oldValuePromise: Promise<OutputType>,\n  ): Promise<OutputType> {\n    return this.derive(await input, oldValuePromise);\n  }\n\n  // TODO: add an indirect layer to cache the derivation?\n  protected abstract derive(\n    input: InputType,\n    oldValuePromise: Promise<OutputType>,\n  ): PromiseOrValue<OutputType>;\n}\n\nexport abstract class SimpleTwistyPropSource<\n  SimpleType,\n> extends TwistyPropSource<SimpleType> {\n  derive(input: SimpleType): PromiseOrValue<SimpleType> {\n    return input;\n  }\n}\n\n// TODO: Can we support `null` as a valid output value without loosening type\n// safety?\nexport const NO_VALUE = Symbol(\"no value\");\nexport type NoValueType = typeof NO_VALUE;\n\nexport abstract class TwistyPropDerived<\n  InputTypes extends InputRecord,\n  OutputType,\n> extends TwistyPropParent<OutputType> {\n  // cachedInputs:\n  #parents: InputProps<InputTypes>;\n\n  constructor(\n    parents: InputProps<InputTypes>,\n    protected userVisibleErrorTracker?: UserVisibleErrorTracker,\n  ) {\n    super();\n    this.#parents = parents;\n    for (const parent of Object.values(parents)) {\n      (\n        parent as TwistyPropDerived<InputProps<InputTypes>, OutputType>\n      ).addChild(this);\n    }\n  }\n\n  #cachedLastSuccessfulCalculation: {\n    inputs: InputTypes;\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  #cachedLatestGenerationCalculation: {\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  public async get(): Promise<OutputType> {\n    const generation = this.lastSourceGeneration;\n\n    if (this.#cachedLatestGenerationCalculation?.generation === generation) {\n      return this.#cachedLatestGenerationCalculation.output;\n    }\n\n    const latestGenerationCalculation = {\n      generation,\n      output: this.#cacheDerive(\n        this.#getParents(),\n        generation,\n        this.#cachedLastSuccessfulCalculation,\n      ),\n    };\n    this.#cachedLatestGenerationCalculation = latestGenerationCalculation;\n\n    this.userVisibleErrorTracker?.reset();\n    return latestGenerationCalculation.output;\n  }\n\n  async #getParents(): Promise<InputTypes> {\n    const inputValuePromises: InputPromises<InputRecord> = {} as any; // TODO\n    for (const [key, parent] of Object.entries(this.#parents)) {\n      (inputValuePromises as Record<string, Promise<unknown>>)[key] = (\n        parent as TwistyPropParent<unknown>\n      ).get();\n    }\n\n    const inputs: InputTypes = {} as any; // TODO\n    for (const key in this.#parents) {\n      inputs[key] = (await (\n        inputValuePromises as Record<string, Promise<unknown>>\n      )[key]) as any;\n    }\n    return inputs;\n  }\n\n  async #cacheDerive(\n    inputsPromise: PromiseOrValue<InputTypes>,\n    generation: number,\n    cachedLatestGenerationCalculation: {\n      inputs: InputTypes;\n      output: Promise<OutputType>;\n      generation: number;\n    } | null = null,\n  ): Promise<OutputType> {\n    const inputs = await inputsPromise;\n\n    const cache = (output: OutputType): OutputType => {\n      this.#cachedLastSuccessfulCalculation = {\n        inputs,\n        output: Promise.resolve(output),\n        generation,\n      };\n      return output;\n    };\n\n    if (!cachedLatestGenerationCalculation) {\n      return cache(await this.derive(inputs));\n    }\n\n    const cachedInputs = cachedLatestGenerationCalculation.inputs;\n    for (const key in this.#parents) {\n      const parent = this.#parents[key];\n      if (!parent.canReuse(inputs[key], cachedInputs[key])) {\n        return cache(await this.derive(inputs));\n      }\n    }\n\n    return cachedLatestGenerationCalculation.output;\n  }\n\n  protected abstract derive(input: InputTypes): PromiseOrValue<OutputType>;\n}\n\nexport class FreshListenerManager {\n  #disconnectionFunctions: (() => void)[] = [];\n\n  addListener<T>(\n    prop: TwistyPropParent<T>,\n    listener: (value: T) => void,\n  ): void {\n    let disconnected = false;\n    const wrappedListener = (value: T) => {\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      listener(value);\n    };\n\n    prop.addFreshListener(wrappedListener);\n\n    this.#disconnectionFunctions.push(() => {\n      prop.removeFreshListener(wrappedListener);\n      disconnected = true;\n    });\n  }\n\n  addMultiListener<U, V>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>],\n    listener: (values: [U, V]) => void,\n  ) {\n    let disconnected = false;\n\n    // We're going to get one initial call per prop. We'll ignore all but one.\n    let initialIgnoresLeft = props.length - 1;\n    const wrappedListener = async (_: any) => {\n      if (initialIgnoresLeft > 0) {\n        initialIgnoresLeft--;\n        return;\n      }\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      // We rely on `TwistyProp` caching to give us the full set of latest\n      // values efficiently.\n      const promises = (props as TwistyPropParent<any>[]).map((prop) =>\n        prop.get(),\n      );\n      const values = await Promise.all(promises);\n      listener(values as any); // TODO: fix up types\n    };\n\n    for (const prop of props) {\n      prop.addFreshListener(wrappedListener);\n    }\n\n    this.#disconnectionFunctions.push(() => {\n      for (const prop of props) {\n        prop.removeFreshListener(wrappedListener);\n      }\n      disconnected = true;\n    });\n  }\n\n  disconnect(): void {\n    for (const disconnectionFunction of this.#disconnectionFunctions) {\n      disconnectionFunction();\n    }\n  }\n}\n", "import { SimpleTwistyPropSource } from \"../../TwistyProp\";\n\n// TODO: turn these maps into lists?\n// TODO: alg.cubing.net parity\nexport const experimentalStickerings = {\n  \"full\": true, // default\n  \"centers-only\": true, // TODO\n  \"PLL\": true,\n  \"CLS\": true,\n  \"OLL\": true,\n  \"COLL\": true,\n  \"OCLL\": true,\n  \"CLL\": true,\n  \"ELL\": true,\n  \"ELS\": true,\n  \"LL\": true,\n  \"F2L\": true,\n  \"ZBLL\": true,\n  \"ZBLS\": true,\n  \"WVLS\": true,\n  \"VLS\": true,\n  \"LS\": true,\n  \"EO\": true,\n  \"EOline\": true,\n  \"EOcross\": true,\n  \"CMLL\": true,\n  \"L6E\": true,\n  \"L6EO\": true,\n  \"Daisy\": true,\n  \"Cross\": true,\n  \"2x2x2\": true,\n  \"2x2x3\": true,\n  \"Void Cube\": true,\n  \"invisible\": true,\n  \"picture\": true,\n  \"experimental-centers-U\": true,\n  \"experimental-centers-U-D\": true,\n  \"experimental-centers-U-L-D\": true,\n  \"experimental-centers-U-L-B-D\": true,\n  \"experimental-centers\": true,\n  \"experimental-fto-fc\": true,\n  \"experimental-fto-f2t\": true,\n  \"experimental-fto-sc\": true,\n  \"experimental-fto-l2c\": true,\n  \"experimental-fto-lbt\": true,\n  \"experimental-fto-l3t\": true,\n  \"experimental-global-custom-1\": true,\n  \"experimental-global-custom-2\": true,\n};\nexport type ExperimentalStickering = keyof typeof experimentalStickerings;\n\nexport class StickeringProp extends SimpleTwistyPropSource<ExperimentalStickering> {\n  getDefaultValue(): ExperimentalStickering {\n    return \"full\"; // TODO: auto\n  }\n}\n", "import { SimpleTwistyPropSource } from \"../../TwistyProp\";\n\n// TODO: turn these maps into lists?\nexport const hintFaceletStyles = {\n  floating: true, // default\n  none: true,\n};\nexport type HintFaceletStyle = keyof typeof hintFaceletStyles;\nexport type HintFaceletStyleWithAuto = HintFaceletStyle | \"auto\";\n\nexport class HintFaceletProp extends SimpleTwistyPropSource<HintFaceletStyleWithAuto> {\n  getDefaultValue(): HintFaceletStyleWithAuto {\n    return \"auto\";\n  }\n}\n", "export const TAU = Math.PI * 2;\nexport const DEGREES_PER_RADIAN = 360 / TAU;\n", "import { from } from \"../../vendor/p-lazy/p-lazy\";\n\n// TODO can we remove the cached proxy?\n\n// In theory we can, but we've run into situations where imports are not properly cached.\nlet cachedConstructorProxy: Promise<\n  typeof import(\"./dynamic-entries/3d-dynamic\")\n> | null = null;\n\nexport async function proxy3D(): Promise<\n  typeof import(\"./dynamic-entries/3d-dynamic\")\n> {\n  return (cachedConstructorProxy ??= import(\"./dynamic-entries/3d-dynamic\"));\n}\n\nexport const THREEJS: Promise<typeof import(\"three\")> = from(\n  async () => (await proxy3D()).T3I,\n);\n"],
  "mappings": "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",
  "names": []
}
