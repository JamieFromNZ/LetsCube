import {
  Alg,
  Move,
  TraversalDownUp
} from "./chunk-DO7GZAW4.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-MGJA5U5O.js";

// src/cubing/kpuzzle/combine.ts
function combineTransformationData(definition, transformationData1, transformationData2) {
  const newTransformationData = {};
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const orbit1 = transformationData1[orbitName];
    const orbit2 = transformationData2[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit2)) {
      newTransformationData[orbitName] = orbit1;
    } else if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit1)) {
      newTransformationData[orbitName] = orbit2;
    } else {
      const newPerm = new Array(orbitDefinition.numPieces);
      if (orbitDefinition.numOrientations === 1) {
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];
        }
        newTransformationData[orbitName] = {
          permutation: newPerm,
          orientation: orbit1.orientation
        };
      } else {
        const newOri = new Array(orbitDefinition.numPieces);
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;
          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];
        }
        newTransformationData[orbitName] = {
          permutation: newPerm,
          orientation: newOri
        };
      }
    }
  }
  return newTransformationData;
}
function applyTransformationDataToStateData(definition, stateData, transformationData) {
  const newStateData = {};
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const orbit1 = stateData[orbitName];
    const orbit2 = transformationData[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit2)) {
      newStateData[orbitName] = orbit1;
    } else {
      const newPieces = new Array(orbitDefinition.numPieces);
      if (orbitDefinition.numOrientations === 1) {
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];
        }
        newStateData[orbitName] = {
          pieces: newPieces,
          orientation: orbit1.orientation
        };
      } else {
        const newOri = new Array(orbitDefinition.numPieces);
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;
          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];
        }
        newStateData[orbitName] = {
          pieces: newPieces,
          orientation: newOri
        };
      }
    }
  }
  return newStateData;
}

// src/cubing/kpuzzle/construct.ts
var FREEZE = false;
var identityOrbitCache = /* @__PURE__ */ new Map();
function constructIdentityOrbitTransformation(numPieces) {
  const cached = identityOrbitCache.get(numPieces);
  if (cached) {
    return cached;
  }
  const newPermutation = new Array(numPieces);
  const newOrientation = new Array(numPieces);
  for (let i = 0; i < numPieces; i++) {
    newPermutation[i] = i;
    newOrientation[i] = 0;
  }
  const orbitTransformation = {
    permutation: newPermutation,
    orientation: newOrientation
  };
  if (FREEZE) {
    Object.freeze(newPermutation);
    Object.freeze(newOrientation);
    Object.freeze(orbitTransformation);
  }
  identityOrbitCache.set(numPieces, orbitTransformation);
  return orbitTransformation;
}
function constructIdentityTransformationDataUncached(definition) {
  const transformation = {};
  for (const [orbitName, orbitDefinition] of Object.entries(definition.orbits)) {
    transformation[orbitName] = constructIdentityOrbitTransformation(orbitDefinition.numPieces);
  }
  if (FREEZE) {
    Object.freeze(transformation);
  }
  return transformation;
}
function moveToTransformationUncached(kpuzzle, move) {
  const quantumKey = move.quantum.toString();
  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey];
  if (!quantumMoveDefinition) {
    const derivedFrom = kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];
    if (derivedFrom) {
      quantumMoveDefinition = kpuzzle.algToTransformation(derivedFrom).transformationData;
    }
  }
  if (quantumMoveDefinition) {
    return repeatTransformationUncached(kpuzzle, quantumMoveDefinition, move.amount);
  }
  const moveDefinition = kpuzzle.definition.moves[move.toString()];
  if (moveDefinition) {
    return moveDefinition;
  }
  const inverseMoveDefinition = kpuzzle.definition.moves[move.invert().toString()];
  if (inverseMoveDefinition) {
    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);
  }
  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);
}

// src/cubing/kpuzzle/3x3x3/puzzle-orientation.ts
function experimentalIs3x3x3Solved(state, options) {
  if (options.ignorePuzzleOrientation) {
    state = normalizePuzzleOrientation(state);
  }
  if (options.ignoreCenterOrientation) {
    state = new KState(state.kpuzzle, {
      EDGES: state.stateData.EDGES,
      CORNERS: state.stateData.CORNERS,
      CENTERS: {
        pieces: state.stateData.CENTERS.pieces,
        orientation: new Array(6).fill(0)
      }
    });
  }
  return !!state.experimentalToTransformation()?.isIdentityTransformation();
}

// src/cubing/kpuzzle/KState.ts
var KState = class {
  constructor(kpuzzle, stateData) {
    this.kpuzzle = kpuzzle;
    this.stateData = stateData;
  }
  toJSON() {
    return {
      experimentalPuzzleName: this.kpuzzle.name(),
      stateData: this.stateData
    };
  }
  static fromTransformation(transformation) {
    const newStateData = applyTransformationDataToStateData(transformation.kpuzzle.definition, transformation.kpuzzle.definition.startStateData, transformation.transformationData);
    return new KState(transformation.kpuzzle, newStateData);
  }
  apply(source) {
    return this.applyTransformation(this.kpuzzle.toTransformation(source));
  }
  applyTransformation(transformation) {
    if (transformation.isIdentityTransformation()) {
      return new KState(this.kpuzzle, this.stateData);
    }
    const newStateData = applyTransformationDataToStateData(this.kpuzzle.definition, this.stateData, transformation.transformationData);
    return new KState(this.kpuzzle, newStateData);
  }
  applyMove(move) {
    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));
  }
  applyAlg(alg) {
    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));
  }
  experimentalToTransformation() {
    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {
      return null;
    }
    const transformationData = {};
    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {
      const transformationOrbit = {
        permutation: stateOrbitData.pieces,
        orientation: stateOrbitData.orientation
      };
      transformationData[orbitName] = transformationOrbit;
    }
    return new KTransformation(this.kpuzzle, transformationData);
  }
  experimentalIs3x3x3Solved(options) {
    if (this.kpuzzle.name() !== "3x3x3") {
      throw new Error("`KState.experimentalIs3x3x3Solved()` only supports 3x3x3 states.");
    }
    return experimentalIs3x3x3Solved(this, options);
  }
};

// src/cubing/kpuzzle/KTransformation.ts
var _cachedIsIdentity;
var _KTransformation = class {
  constructor(kpuzzle, transformationData) {
    this.kpuzzle = kpuzzle;
    this.transformationData = transformationData;
    __privateAdd(this, _cachedIsIdentity, void 0);
  }
  toJSON() {
    return {
      experimentalPuzzleName: this.kpuzzle.name(),
      transformationData: this.transformationData
    };
  }
  invert() {
    return new _KTransformation(this.kpuzzle, invertTransformation(this.kpuzzle, this.transformationData));
  }
  isIdentityTransformation() {
    return __privateGet(this, _cachedIsIdentity) ?? __privateSet(this, _cachedIsIdentity, this.isIdentical(this.kpuzzle.identityTransformation()));
  }
  static experimentalConstructIdentity(kpuzzle) {
    const transformation = new _KTransformation(kpuzzle, constructIdentityTransformationDataUncached(kpuzzle.definition));
    __privateSet(transformation, _cachedIsIdentity, true);
    return transformation;
  }
  isIdentical(t2) {
    return isTransformationDataIdentical(this.kpuzzle, this.transformationData, t2.transformationData);
  }
  apply(source) {
    return this.applyTransformation(this.kpuzzle.toTransformation(source));
  }
  applyTransformation(t2) {
    if (this.kpuzzle !== t2.kpuzzle) {
      throw new Error(`Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`);
    }
    if (__privateGet(this, _cachedIsIdentity)) {
      return new _KTransformation(this.kpuzzle, t2.transformationData);
    }
    if (__privateGet(t2, _cachedIsIdentity)) {
      return new _KTransformation(this.kpuzzle, this.transformationData);
    }
    return new _KTransformation(this.kpuzzle, combineTransformationData(this.kpuzzle.definition, this.transformationData, t2.transformationData));
  }
  applyMove(move) {
    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));
  }
  applyAlg(alg) {
    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));
  }
  toKState() {
    return KState.fromTransformation(this);
  }
  repetitionOrder() {
    return transformationRepetitionOrder(this.kpuzzle.definition, this);
  }
  selfMultiply(amount) {
    return new _KTransformation(this.kpuzzle, repeatTransformationUncached(this.kpuzzle, this.transformationData, amount));
  }
};
var KTransformation = _KTransformation;
_cachedIsIdentity = new WeakMap();

// src/cubing/kpuzzle/calculate.ts
function isOrbitTransformationDataIdentityUncached(numOrientations, orbitTransformationData) {
  const { permutation } = orbitTransformationData;
  const numPieces = permutation.length;
  for (let idx = 0; idx < numPieces; idx++) {
    if (permutation[idx] !== idx) {
      return false;
    }
  }
  if (numOrientations > 1) {
    const { orientation } = orbitTransformationData;
    for (let idx = 0; idx < numPieces; idx++) {
      if (orientation[idx] !== 0) {
        return false;
      }
    }
  }
  return true;
}
function isOrbitTransformationDataIdentical(orbitDefinition, orbitTransformationData1, orbitTransformationData2, options = {}) {
  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
    if (!options?.ignoreOrientation && orbitTransformationData1.orientation[idx] !== orbitTransformationData2.orientation[idx]) {
      return false;
    }
    if (!options?.ignorePermutation && orbitTransformationData1.permutation[idx] !== orbitTransformationData2.permutation[idx]) {
      return false;
    }
  }
  return true;
}
function isTransformationDataIdentical(kpuzzle, transformationData1, transformationData2) {
  for (const [orbitName, orbitDefinition] of Object.entries(kpuzzle.definition.orbits)) {
    if (!isOrbitTransformationDataIdentical(orbitDefinition, transformationData1[orbitName], transformationData2[orbitName])) {
      return false;
    }
  }
  return true;
}
function invertTransformation(kpuzzle, transformationData) {
  const newTransformationData = {};
  for (const orbitName in kpuzzle.definition.orbits) {
    const orbitDefinition = kpuzzle.definition.orbits[orbitName];
    const orbitTransformationData = transformationData[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbitTransformationData)) {
      newTransformationData[orbitName] = orbitTransformationData;
    } else if (orbitDefinition.numOrientations === 1) {
      const newPerm = new Array(orbitDefinition.numPieces);
      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
        newPerm[orbitTransformationData.permutation[idx]] = idx;
      }
      newTransformationData[orbitName] = {
        permutation: newPerm,
        orientation: orbitTransformationData.orientation
      };
    } else {
      const newPerm = new Array(orbitDefinition.numPieces);
      const newOri = new Array(orbitDefinition.numPieces);
      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
        const fromIdx = orbitTransformationData.permutation[idx];
        newPerm[fromIdx] = idx;
        newOri[fromIdx] = (orbitDefinition.numOrientations - orbitTransformationData.orientation[idx] + orbitDefinition.numOrientations) % orbitDefinition.numOrientations;
      }
      newTransformationData[orbitName] = {
        permutation: newPerm,
        orientation: newOri
      };
    }
  }
  return newTransformationData;
}
function repeatTransformationUncached(kpuzzle, transformationData, amount) {
  if (amount === 1) {
    return transformationData;
  }
  if (amount < 0) {
    return repeatTransformationUncached(kpuzzle, invertTransformation(kpuzzle, transformationData), -amount);
  }
  if (amount === 0) {
    const { transformationData: transformationData2 } = kpuzzle.identityTransformation();
    return transformationData2;
  }
  let halfish = transformationData;
  if (amount !== 2) {
    halfish = repeatTransformationUncached(kpuzzle, transformationData, Math.floor(amount / 2));
  }
  const twiceHalfish = combineTransformationData(kpuzzle.definition, halfish, halfish);
  if (amount % 2 === 0) {
    return twiceHalfish;
  } else {
    return combineTransformationData(kpuzzle.definition, transformationData, twiceHalfish);
  }
}
var AlgToTransformationTraversal = class extends TraversalDownUp {
  traverseAlg(alg, kpuzzle) {
    let transformation = null;
    for (const unit of alg.units()) {
      if (transformation) {
        transformation = transformation.applyTransformation(this.traverseUnit(unit, kpuzzle));
      } else {
        transformation = this.traverseUnit(unit, kpuzzle);
      }
    }
    return transformation ?? kpuzzle.identityTransformation();
  }
  traverseGrouping(grouping, kpuzzle) {
    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);
    return new KTransformation(kpuzzle, repeatTransformationUncached(kpuzzle, algTransformation.transformationData, grouping.amount));
  }
  traverseMove(move, kpuzzle) {
    return kpuzzle.moveToTransformation(move);
  }
  traverseCommutator(commutator, kpuzzle) {
    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);
    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);
    return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert()).applyTransformation(bTransformation.invert());
  }
  traverseConjugate(conjugate, kpuzzle) {
    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);
    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);
    return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert());
  }
  traversePause(_, kpuzzle) {
    return kpuzzle.identityTransformation();
  }
  traverseNewline(_, kpuzzle) {
    return kpuzzle.identityTransformation();
  }
  traverseLineComment(_, kpuzzle) {
    return kpuzzle.identityTransformation();
  }
};
var algToTransformationInstance = new AlgToTransformationTraversal();
var algToTransformation = algToTransformationInstance.traverseAlg.bind(algToTransformationInstance);
function gcd(a, b) {
  if (b) {
    return gcd(b, a % b);
  }
  return a;
}
function transformationRepetitionOrder(definition, transformation) {
  let order = 1;
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const transformationOrbit = transformation.transformationData[orbitName];
    const orbitPieces = new Array(orbitDefinition.numPieces);
    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {
      if (!orbitPieces[startIdx]) {
        let currentIdx = startIdx;
        let orientationSum = 0;
        let cycleLength = 0;
        for (; ; ) {
          orbitPieces[currentIdx] = true;
          orientationSum = orientationSum + transformationOrbit.orientation[currentIdx];
          cycleLength = cycleLength + 1;
          currentIdx = transformationOrbit.permutation[currentIdx];
          if (currentIdx === startIdx) {
            break;
          }
        }
        if (orientationSum !== 0) {
          cycleLength = cycleLength * orbitDefinition.numOrientations / gcd(orbitDefinition.numOrientations, orientationSum);
        }
        order = order * cycleLength / gcd(order, cycleLength);
      }
    }
  }
  return order;
}

// src/cubing/kpuzzle/KPuzzle.ts
var _moveToTransformationDataCache, _cachedCanConvertStateToUniqueTransformation;
var KPuzzle = class {
  constructor(definition, options) {
    this.definition = definition;
    __privateAdd(this, _moveToTransformationDataCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _cachedCanConvertStateToUniqueTransformation, void 0);
    this.experimentalPGNotation = options?.experimentalPGNotation;
  }
  name() {
    return this.definition.name;
  }
  identityTransformation() {
    return KTransformation.experimentalConstructIdentity(this);
  }
  moveToTransformation(move) {
    if (typeof move === "string") {
      move = new Move(move);
    }
    const cacheKey = move.toString();
    const cachedTransformationData = __privateGet(this, _moveToTransformationDataCache).get(cacheKey);
    if (cachedTransformationData) {
      return new KTransformation(this, cachedTransformationData);
    }
    if (this.experimentalPGNotation) {
      const transformationData2 = this.experimentalPGNotation.lookupMove(move);
      if (!transformationData2) {
        throw new Error(`could not map to internal move: ${move}`);
      }
      __privateGet(this, _moveToTransformationDataCache).set(cacheKey, transformationData2);
      return new KTransformation(this, transformationData2);
    }
    const transformationData = moveToTransformationUncached(this, move);
    __privateGet(this, _moveToTransformationDataCache).set(cacheKey, transformationData);
    return new KTransformation(this, transformationData);
  }
  algToTransformation(alg) {
    if (typeof alg === "string") {
      alg = new Alg(alg);
    }
    return algToTransformation(alg, this);
  }
  toTransformation(source) {
    if (typeof source === "string") {
      return this.algToTransformation(source);
    } else if (source?.is?.(Alg)) {
      return this.algToTransformation(source);
    } else if (source?.is?.(Move)) {
      return this.moveToTransformation(source);
    } else {
      return source;
    }
  }
  startState() {
    return new KState(this, this.definition.startStateData);
  }
  canConvertStateToUniqueTransformation() {
    return __privateGet(this, _cachedCanConvertStateToUniqueTransformation) ?? __privateSet(this, _cachedCanConvertStateToUniqueTransformation, (() => {
      for (const [orbitName, orbitDefinition] of Object.entries(this.definition.orbits)) {
        const pieces = new Array(orbitDefinition.numPieces).fill(false);
        for (const piece of this.definition.startStateData[orbitName].pieces) {
          pieces[piece] = true;
        }
        for (const piece of pieces) {
          if (!piece) {
            return false;
          }
        }
      }
      return true;
    })());
  }
  get state() {
    throw new Error("KPuzzle is now a different (stateless) class.");
  }
  reset() {
    throw new Error("KPuzzle is now a different (stateless) class.");
  }
  applyMove(_move) {
    throw new Error("KPuzzle is now a different class. Try `.moveToTransformation()` to get the transformation for a move.");
  }
  applyAlg(_alg) {
    throw new Error("KPuzzle is now a different class. Try `.algToTransformation()` to get the transformation for an alg.");
  }
};
_moveToTransformationDataCache = new WeakMap();
_cachedCanConvertStateToUniqueTransformation = new WeakMap();

// src/cubing/kpuzzle/3x3x3/3x3x3.kpuzzle.json.ts
var cube3x3x3KPuzzleDefinition = {
  name: "3x3x3",
  orbits: {
    EDGES: { numPieces: 12, numOrientations: 2 },
    CORNERS: { numPieces: 8, numOrientations: 3 },
    CENTERS: { numPieces: 6, numOrientations: 4 }
  },
  startStateData: {
    EDGES: {
      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    CORNERS: {
      pieces: [0, 1, 2, 3, 4, 5, 6, 7],
      orientation: [0, 0, 0, 0, 0, 0, 0, 0]
    },
    CENTERS: {
      pieces: [0, 1, 2, 3, 4, 5],
      orientation: [0, 0, 0, 0, 0, 0]
    }
  },
  moves: {
    U: {
      EDGES: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [1, 0, 0, 0, 0, 0]
      }
    },
    y: {
      EDGES: {
        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 7, 4, 5, 6],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 2, 3, 4, 1, 5],
        orientation: [1, 0, 0, 0, 0, 3]
      }
    },
    x: {
      EDGES: {
        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 3, 5, 7, 6, 2, 1],
        orientation: [2, 1, 2, 1, 1, 2, 1, 2]
      },
      CENTERS: {
        permutation: [2, 1, 5, 3, 0, 4],
        orientation: [0, 3, 0, 1, 2, 2]
      }
    },
    L: {
      EDGES: {
        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 6, 2, 4, 3, 5, 7],
        orientation: [0, 0, 2, 1, 0, 2, 1, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 1, 0, 0, 0, 0]
      }
    },
    F: {
      EDGES: {
        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],
        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0]
      },
      CORNERS: {
        permutation: [3, 1, 2, 5, 0, 4, 6, 7],
        orientation: [1, 0, 0, 2, 2, 1, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 1, 0, 0, 0]
      }
    },
    R: {
      EDGES: {
        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 2, 3, 7, 5, 6, 1],
        orientation: [2, 1, 0, 0, 1, 0, 0, 2]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 1, 0, 0]
      }
    },
    B: {
      EDGES: {
        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],
        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1]
      },
      CORNERS: {
        permutation: [0, 7, 1, 3, 4, 5, 2, 6],
        orientation: [0, 2, 1, 0, 0, 0, 2, 1]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 0, 1, 0]
      }
    },
    D: {
      EDGES: {
        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 5, 6, 7, 4],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 0, 0, 1]
      }
    },
    z: {
      EDGES: {
        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],
        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [3, 2, 6, 5, 0, 4, 7, 1],
        orientation: [1, 2, 1, 2, 2, 1, 2, 1]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 1, 1, 3, 1]
      }
    },
    M: {
      EDGES: {
        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [4, 1, 0, 3, 5, 2],
        orientation: [2, 0, 0, 0, 2, 0]
      }
    },
    E: {
      EDGES: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 4, 1, 2, 3, 5],
        orientation: [0, 0, 0, 0, 0, 0]
      }
    },
    S: {
      EDGES: {
        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],
        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 0, 1, 0, 1]
      }
    },
    u: {
      EDGES: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 2, 3, 4, 1, 5],
        orientation: [1, 0, 0, 0, 0, 0]
      }
    },
    l: {
      EDGES: {
        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 6, 2, 4, 3, 5, 7],
        orientation: [0, 0, 2, 1, 0, 2, 1, 0]
      },
      CENTERS: {
        permutation: [4, 1, 0, 3, 5, 2],
        orientation: [2, 1, 0, 0, 2, 0]
      }
    },
    f: {
      EDGES: {
        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],
        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0]
      },
      CORNERS: {
        permutation: [3, 1, 2, 5, 0, 4, 6, 7],
        orientation: [1, 0, 0, 2, 2, 1, 0, 0]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 1, 1, 0, 1]
      }
    },
    r: {
      EDGES: {
        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 2, 3, 7, 5, 6, 1],
        orientation: [2, 1, 0, 0, 1, 0, 0, 2]
      },
      CENTERS: {
        permutation: [2, 1, 5, 3, 0, 4],
        orientation: [0, 0, 0, 1, 2, 2]
      }
    },
    b: {
      EDGES: {
        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],
        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1]
      },
      CORNERS: {
        permutation: [0, 7, 1, 3, 4, 5, 2, 6],
        orientation: [0, 2, 1, 0, 0, 0, 2, 1]
      },
      CENTERS: {
        permutation: [3, 0, 2, 5, 4, 1],
        orientation: [3, 3, 0, 3, 1, 3]
      }
    },
    d: {
      EDGES: {
        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 5, 6, 7, 4],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 4, 1, 2, 3, 5],
        orientation: [0, 0, 0, 0, 0, 1]
      }
    }
  }
};
cube3x3x3KPuzzleDefinition.moves["Uw"] = cube3x3x3KPuzzleDefinition.moves["u"];
cube3x3x3KPuzzleDefinition.moves["Lw"] = cube3x3x3KPuzzleDefinition.moves["l"];
cube3x3x3KPuzzleDefinition.moves["Fw"] = cube3x3x3KPuzzleDefinition.moves["f"];
cube3x3x3KPuzzleDefinition.moves["Rw"] = cube3x3x3KPuzzleDefinition.moves["r"];
cube3x3x3KPuzzleDefinition.moves["Bw"] = cube3x3x3KPuzzleDefinition.moves["b"];
cube3x3x3KPuzzleDefinition.moves["Dw"] = cube3x3x3KPuzzleDefinition.moves["d"];
cube3x3x3KPuzzleDefinition.moves["Rv"] = cube3x3x3KPuzzleDefinition.moves["x"];
cube3x3x3KPuzzleDefinition.moves["Uv"] = cube3x3x3KPuzzleDefinition.moves["y"];
cube3x3x3KPuzzleDefinition.moves["Fv"] = cube3x3x3KPuzzleDefinition.moves["z"];
cube3x3x3KPuzzleDefinition.moves["Lv"] = {
  EDGES: {
    permutation: [2, 10, 6, 11, 0, 8, 4, 9, 1, 3, 5, 7],
    orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
  },
  CORNERS: {
    permutation: [1, 7, 6, 2, 0, 3, 5, 4],
    orientation: [2, 1, 2, 1, 1, 2, 1, 2]
  },
  CENTERS: {
    permutation: [4, 1, 0, 3, 5, 2],
    orientation: [2, 1, 0, 3, 2, 0]
  }
};
cube3x3x3KPuzzleDefinition.moves["Dv"] = {
  EDGES: {
    permutation: [3, 0, 1, 2, 7, 4, 5, 6, 9, 11, 8, 10],
    orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
  },
  CORNERS: {
    permutation: [3, 0, 1, 2, 5, 6, 7, 4],
    orientation: [0, 0, 0, 0, 0, 0, 0, 0]
  },
  CENTERS: {
    permutation: [0, 4, 1, 2, 3, 5],
    orientation: [3, 0, 0, 0, 0, 1]
  }
};
cube3x3x3KPuzzleDefinition.moves["Bv"] = {
  EDGES: {
    permutation: [8, 5, 10, 1, 9, 7, 11, 3, 4, 0, 6, 2],
    orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  },
  CORNERS: {
    permutation: [4, 7, 1, 0, 5, 3, 2, 6],
    orientation: [1, 2, 1, 2, 2, 1, 2, 1]
  },
  CENTERS: {
    permutation: [3, 0, 2, 5, 4, 1],
    orientation: [3, 3, 3, 3, 1, 3]
  }
};

// src/cubing/kpuzzle/index.ts
var experimental3x3x3KPuzzle = new KPuzzle(cube3x3x3KPuzzleDefinition);

// src/cubing/protocol/binary/orbit-indexing.ts
function identityPermutation(numElems) {
  const arr = new Array(numElems);
  for (let i = 0; i < numElems; i++) {
    arr[i] = i;
  }
  return arr;
}
function orientationsToMask(radix, orientations) {
  let val = 0;
  for (const orientation of orientations) {
    val *= radix;
    val += orientation;
  }
  return val;
}
function maskToOrientations(radix, numElems, mask) {
  const arr = [];
  while (mask > 0) {
    arr.push(mask % radix);
    mask = Math.floor(mask / radix);
  }
  return new Array(numElems - arr.length).fill(0).concat(arr.reverse());
}
function permutationToLex(permutation) {
  const n = permutation.length;
  let lexicographicIdx = 0;
  for (let i = 0; i < n - 1; i++) {
    lexicographicIdx = lexicographicIdx * (n - i);
    for (let j = i + 1; j < n; j++) {
      if (permutation[i] > permutation[j]) {
        lexicographicIdx += 1;
      }
    }
  }
  return lexicographicIdx;
}
function lexToPermutation(numPieces, lexicographicIdx) {
  const permutation = new Array(numPieces);
  permutation[numPieces - 1] = 0;
  for (let i = numPieces - 2; i >= 0; i--) {
    permutation[i] = lexicographicIdx % (numPieces - i);
    lexicographicIdx = Math.floor(lexicographicIdx / (numPieces - i));
    for (let j = i + 1; j < numPieces; j++) {
      if (permutation[j] >= permutation[i]) {
        permutation[j] = permutation[j] + 1;
      }
    }
  }
  return permutation;
}

// src/cubing/protocol/binary/puzzle-orientation.ts
function puzzleOrientationIdx(state) {
  const idxU = state.stateData["CENTERS"].pieces[0];
  const idxD = state.stateData["CENTERS"].pieces[5];
  const unadjustedIdxL = state.stateData["CENTERS"].pieces[1];
  let idxL = unadjustedIdxL;
  if (idxU < unadjustedIdxL) {
    idxL--;
  }
  if (idxD < unadjustedIdxL) {
    idxL--;
  }
  return [idxU, idxL];
}
var puzzleOrientationCacheRaw = new Array(6).fill(0).map(() => {
  return new Array(6);
});
var puzzleOrientationCacheInitialized = false;
function puzzleOrientationCache() {
  if (!puzzleOrientationCacheInitialized) {
    {
      const uAlgs = ["", "z", "x", "z'", "x'", "x2"].map((s) => Alg.fromString(s));
      const yAlg = new Alg("y");
      for (const uAlg of uAlgs) {
        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);
        for (let i = 0; i < 4; i++) {
          transformation = transformation.applyAlg(yAlg);
          const [idxU, idxL] = puzzleOrientationIdx(transformation.toKState());
          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();
        }
      }
    }
  }
  return puzzleOrientationCacheRaw;
}
function normalizePuzzleOrientation(state) {
  const [idxU, idxL] = puzzleOrientationIdx(state);
  const orientationTransformation = puzzleOrientationCache()[idxU][idxL];
  return state.applyTransformation(orientationTransformation);
}
function reorientPuzzle(state, idxU, idxL) {
  return state.applyTransformation(puzzleOrientationCache()[idxU][idxL].invert());
}

// src/cubing/protocol/binary/binary3x3x3.ts
var BIT_LENGTHS = [29, 12, 16, 13, 3, 2, 1, 12];
function arraySum(arr) {
  let total = 0;
  for (const entry of arr) {
    total += entry;
  }
  return total;
}
function splitBinary(bitLengths, buffy) {
  const u8buffy = new Uint8Array(buffy);
  let at = 0;
  let bits = 0;
  let accum = 0;
  const values = [];
  for (const bitLength of bitLengths) {
    while (bits < bitLength) {
      accum = accum << 8 | u8buffy[at++];
      bits += 8;
    }
    values.push(accum >> bits - bitLength & (1 << bitLength) - 1);
    bits -= bitLength;
  }
  return values;
}
function concatBinary(bitLengths, values) {
  const buffy = new Uint8Array(Math.ceil(arraySum(bitLengths) / 8));
  let at = 0;
  let bits = 0;
  let accum = 0;
  for (let i = 0; i < bitLengths.length; i++) {
    accum = accum << bitLengths[i] | values[i];
    bits += bitLengths[i];
    while (bits >= 8) {
      buffy[at++] = accum >> bits - 8;
      bits -= 8;
    }
  }
  if (bits > 0) {
    buffy[at++] = accum << 8 - bits;
  }
  return buffy;
}
function supportsPuzzleOrientation(components) {
  return components.poIdxU !== 7;
}
function reid3x3x3ToBinaryComponents(state) {
  const normedState = normalizePuzzleOrientation(state);
  const epLex = permutationToLex(normedState.stateData["EDGES"].pieces);
  const eoMask = orientationsToMask(2, normedState.stateData["EDGES"].orientation);
  const cpLex = permutationToLex(normedState.stateData["CORNERS"].pieces);
  const coMask = orientationsToMask(3, normedState.stateData["CORNERS"].orientation);
  const [poIdxU, poIdxL] = puzzleOrientationIdx(state);
  const moSupport = 1;
  const moMask = orientationsToMask(4, normedState.stateData["CENTERS"].orientation);
  return {
    epLex,
    eoMask,
    cpLex,
    coMask,
    poIdxU,
    poIdxL,
    moSupport,
    moMask
  };
}
function binaryComponentsToTwizzleBinary(components) {
  const { epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask } = components;
  return concatBinary(BIT_LENGTHS, [
    epLex,
    eoMask,
    cpLex,
    coMask,
    poIdxU,
    poIdxL,
    moSupport,
    moMask
  ]);
}
function reid3x3x3ToTwizzleBinary(state) {
  const components = reid3x3x3ToBinaryComponents(state);
  return binaryComponentsToTwizzleBinary(components);
}
function twizzleBinaryToBinaryComponents(buffer) {
  const [epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask] = splitBinary(BIT_LENGTHS, buffer);
  return {
    epLex,
    eoMask,
    cpLex,
    coMask,
    poIdxU,
    poIdxL,
    moSupport,
    moMask
  };
}
function binaryComponentsToReid3x3x3(components) {
  if (components.moSupport !== 1) {
    throw new Error("Must support center orientation.");
  }
  const normedState = new KState(experimental3x3x3KPuzzle, {
    EDGES: {
      pieces: lexToPermutation(12, components.epLex),
      orientation: maskToOrientations(2, 12, components.eoMask)
    },
    CORNERS: {
      pieces: lexToPermutation(8, components.cpLex),
      orientation: maskToOrientations(3, 8, components.coMask)
    },
    CENTERS: {
      pieces: identityPermutation(6),
      orientation: maskToOrientations(4, 6, components.moMask)
    }
  });
  if (!supportsPuzzleOrientation(components)) {
    return normedState;
  }
  return reorientPuzzle(normedState, components.poIdxU, components.poIdxL);
}
function validateComponents(components) {
  const errors = [];
  if (components.epLex < 0 || components.epLex >= 479001600) {
    errors.push(`epLex (${components.epLex}) out of range`);
  }
  if (components.cpLex < 0 || components.cpLex >= 40320) {
    errors.push(`cpLex (${components.cpLex}) out of range`);
  }
  if (components.coMask < 0 || components.coMask >= 6561) {
    errors.push(`coMask (${components.coMask}) out of range`);
  }
  if (components.poIdxU < 0 || components.poIdxU >= 6) {
    if (supportsPuzzleOrientation(components)) {
      errors.push(`poIdxU (${components.poIdxU}) out of range`);
    }
  }
  if (components.eoMask < 0 || components.eoMask >= 4096) {
    errors.push(`eoMask (${components.eoMask}) out of range`);
  }
  if (components.moMask < 0 || components.moMask >= 4096) {
    errors.push(`moMask (${components.moMask}) out of range`);
  }
  if (components.poIdxL < 0 || components.poIdxL >= 4) {
    errors.push(`poIdxL (${components.poIdxL}) out of range`);
  }
  if (components.moSupport < 0 || components.moSupport >= 2) {
    errors.push(`moSupport (${components.moSupport}) out of range`);
  }
  return errors;
}
function twizzleBinaryToReid3x3x3(buffy) {
  const components = twizzleBinaryToBinaryComponents(buffy);
  const errors = validateComponents(components);
  if (errors.length !== 0) {
    throw new Error(`Invalid binary state components: ${errors.join(", ")}`);
  }
  return binaryComponentsToReid3x3x3(components);
}

// src/cubing/protocol/binary/hex.ts
function bufferToSpacedHex(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (x) => ("00" + x.toString(16)).slice(-2)).join(" ");
}
function spacedHexToBuffer(hex) {
  return new Uint8Array(hex.split(" ").map((c) => parseInt(c, 16)));
}

export {
  normalizePuzzleOrientation,
  reid3x3x3ToTwizzleBinary,
  twizzleBinaryToBinaryComponents,
  binaryComponentsToReid3x3x3,
  twizzleBinaryToReid3x3x3,
  bufferToSpacedHex,
  spacedHexToBuffer,
  KState,
  KTransformation,
  KPuzzle,
  experimental3x3x3KPuzzle
};
//# sourceMappingURL=chunk-HD2CMNE4.js.map
