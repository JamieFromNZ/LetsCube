{
  "version": 3,
  "sources": ["../../src/cubing/kpuzzle/combine.ts", "../../src/cubing/kpuzzle/construct.ts", "../../src/cubing/kpuzzle/3x3x3/puzzle-orientation.ts", "../../src/cubing/kpuzzle/KState.ts", "../../src/cubing/kpuzzle/KTransformation.ts", "../../src/cubing/kpuzzle/calculate.ts", "../../src/cubing/kpuzzle/KPuzzle.ts", "../../src/cubing/kpuzzle/3x3x3/3x3x3.kpuzzle.json.ts", "../../src/cubing/kpuzzle/index.ts", "../../src/cubing/protocol/binary/orbit-indexing.ts", "../../src/cubing/protocol/binary/puzzle-orientation.ts", "../../src/cubing/protocol/binary/binary3x3x3.ts", "../../src/cubing/protocol/binary/hex.ts"],
  "sourcesContent": ["import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToStateData(\n  definition: KPuzzleDefinition,\n  stateData: KStateData,\n  transformationData: KTransformationData,\n): KStateData {\n  const newStateData = {} as KStateData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n", "import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    definition.orbits,\n  )) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(\n      orbitDefinition.numPieces,\n    );\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey] as\n    | KTransformationData\n    | undefined;\n\n  if (!quantumMoveDefinition) {\n    const derivedFrom =\n      kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n\n    if (derivedFrom) {\n      // TODO: avoid the round trip?\n      quantumMoveDefinition =\n        kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      quantumMoveDefinition,\n      move.amount,\n    );\n  }\n\n  // Handle e.g. `y2` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n\n  // Handle e.g. `y2'` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const inverseMoveDefinition =\n    kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n", "import { experimentalNormalizePuzzleOrientation as normalize3x3x3Orientation } from \"../../protocol\";\nimport { KState } from \"../KState\";\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize3x3x3Orientation(state);\n  }\n  if (options.ignoreCenterOrientation) {\n    state = new KState(state.kpuzzle, {\n      EDGES: state.stateData.EDGES,\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!state.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n", "import type { KPuzzle, KTransformationData } from \".\";\nimport type { Alg, Move } from \"../alg\";\nimport { experimentalIs3x3x3Solved } from \"./3x3x3/puzzle-orientation\";\nimport { applyTransformationDataToStateData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type { KStateData, KTransformationOrbitData } from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport class KState {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly stateData: KStateData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      stateData: this.stateData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KState {\n    const newStateData = applyTransformationDataToStateData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.startStateData,\n      transformation.transformationData,\n    );\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KState {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KState {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(\n      this.kpuzzle.definition,\n      this.stateData,\n      transformation.transformationData,\n    );\n    return new KState(this.kpuzzle, newStateData);\n  }\n\n  applyMove(move: Move | string): KState {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KState {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIs3x3x3Solved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (this.kpuzzle.name() !== \"3x3x3\") {\n      throw new Error(\n        \"`KState.experimentalIs3x3x3Solved()` only supports 3x3x3 states.\",\n      );\n    }\n    return experimentalIs3x3x3Solved(this, options);\n  }\n}\n", "import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKState(): KState {\n    return KState.fromTransformation(this);\n  }\n\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n", "import type { KPuzzleDefinition } from \".\";\nimport {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignoreOrientation?: boolean;\n    ignorePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignoreOrientation &&\n      orbitTransformationData1.orientation[idx] !==\n        orbitTransformationData2.orientation[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    kpuzzle.definition.orbits,\n  )) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitName],\n        transformationData2[orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition: KOrbitDefinition =\n      kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientation[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const unit of alg.units()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseUnit(unit, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseUnit(unit, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nconst algToTransformationInstance = new AlgToTransformationTraversal();\nexport const algToTransformation = algToTransformationInstance.traverseAlg.bind(\n  algToTransformationInstance,\n) as (alg: Alg, kpuzzle: KPuzzle) => KTransformation;\n\nexport function canConvertStateToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(definition)) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.startStateData[orbitName].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, orientationSum);\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n", "import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  startState(): KState {\n    return new KState(this, this.definition.startStateData);\n  }\n\n  #cachedCanConvertStateToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete start state data\n  canConvertStateToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertStateToUniqueTransformation ??=\n      ((): boolean => {\n        for (const [orbitName, orbitDefinition] of Object.entries(\n          this.definition.orbits,\n        )) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.startStateData[orbitName]\n            .pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  get state(): never {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  reset(): never {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  applyMove(_move: Move): never {\n    throw new Error(\n      \"KPuzzle is now a different class. Try `.moveToTransformation()` to get the transformation for a move.\",\n    );\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  applyAlg(_alg: Alg): never {\n    throw new Error(\n      \"KPuzzle is now a different class. Try `.algToTransformation()` to get the transformation for an alg.\",\n    );\n  }\n}\n", "// TODO: This file is here to avoid dependency loops, but it should eventually\n// move back into `cubing/puzzles`. We currently have a few functions that are\n// hardcoded to require synchronous access to this definition, and we need to\n// find a better way to do that.\n\nimport type { KPuzzleDefinition } from \"../KPuzzleDefinition\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 },\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n};\n\ncube3x3x3KPuzzleDefinition.moves[\"Uw\"] = cube3x3x3KPuzzleDefinition.moves[\"u\"];\ncube3x3x3KPuzzleDefinition.moves[\"Lw\"] = cube3x3x3KPuzzleDefinition.moves[\"l\"];\ncube3x3x3KPuzzleDefinition.moves[\"Fw\"] = cube3x3x3KPuzzleDefinition.moves[\"f\"];\ncube3x3x3KPuzzleDefinition.moves[\"Rw\"] = cube3x3x3KPuzzleDefinition.moves[\"r\"];\ncube3x3x3KPuzzleDefinition.moves[\"Bw\"] = cube3x3x3KPuzzleDefinition.moves[\"b\"];\ncube3x3x3KPuzzleDefinition.moves[\"Dw\"] = cube3x3x3KPuzzleDefinition.moves[\"d\"];\n\ncube3x3x3KPuzzleDefinition.moves[\"Rv\"] = cube3x3x3KPuzzleDefinition.moves[\"x\"];\ncube3x3x3KPuzzleDefinition.moves[\"Uv\"] = cube3x3x3KPuzzleDefinition.moves[\"y\"];\ncube3x3x3KPuzzleDefinition.moves[\"Fv\"] = cube3x3x3KPuzzleDefinition.moves[\"z\"];\ncube3x3x3KPuzzleDefinition.moves[\"Lv\"] = {\n  EDGES: {\n    permutation: [2, 10, 6, 11, 0, 8, 4, 9, 1, 3, 5, 7],\n    orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n  },\n  CORNERS: {\n    permutation: [1, 7, 6, 2, 0, 3, 5, 4],\n    orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n  },\n  CENTERS: {\n    permutation: [4, 1, 0, 3, 5, 2],\n    orientation: [2, 1, 0, 3, 2, 0],\n  },\n};\ncube3x3x3KPuzzleDefinition.moves[\"Dv\"] = {\n  EDGES: {\n    permutation: [3, 0, 1, 2, 7, 4, 5, 6, 9, 11, 8, 10],\n    orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n  },\n  CORNERS: {\n    permutation: [3, 0, 1, 2, 5, 6, 7, 4],\n    orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n  },\n  CENTERS: {\n    permutation: [0, 4, 1, 2, 3, 5],\n    orientation: [3, 0, 0, 0, 0, 1],\n  },\n};\ncube3x3x3KPuzzleDefinition.moves[\"Bv\"] = {\n  EDGES: {\n    permutation: [8, 5, 10, 1, 9, 7, 11, 3, 4, 0, 6, 2],\n    orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  },\n  CORNERS: {\n    permutation: [4, 7, 1, 0, 5, 3, 2, 6],\n    orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n  },\n  CENTERS: {\n    permutation: [3, 0, 2, 5, 4, 1],\n    orientation: [3, 3, 3, 3, 1, 3],\n  },\n};\n", "export { KPuzzle } from \"./KPuzzle\";\nexport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nexport { KState } from \"./KState\";\nexport { KTransformation } from \"./KTransformation\";\n\nimport { cube3x3x3KPuzzleDefinition } from \"./3x3x3/3x3x3.kpuzzle.json\";\nimport { KPuzzle } from \"./KPuzzle\";\nexport const experimental3x3x3KPuzzle = new KPuzzle(cube3x3x3KPuzzleDefinition);\n", "export function identityPermutation(numElems: number): number[] {\n  const arr = new Array<number>(numElems);\n  for (let i = 0; i < numElems; i++) {\n    arr[i] = i;\n  }\n  return arr;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function orientationsToMask(\n  radix: number,\n  orientations: number[],\n): number {\n  let val = 0;\n  for (const orientation of orientations) {\n    val *= radix;\n    val += orientation;\n  }\n  return val;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function maskToOrientations(\n  radix: number,\n  numElems: number,\n  mask: number,\n): number[] {\n  const arr = [];\n  while (mask > 0) {\n    arr.push(mask % radix);\n    mask = Math.floor(mask / radix);\n  }\n  return new Array<number>(numElems - arr.length).fill(0).concat(arr.reverse());\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function permutationToLex(permutation: number[]): number {\n  const n = permutation.length;\n  let lexicographicIdx = 0;\n  for (let i = 0; i < n - 1; i++) {\n    lexicographicIdx = lexicographicIdx * (n - i);\n    for (let j = i + 1; j < n; j++) {\n      if (permutation[i] > permutation[j]) {\n        lexicographicIdx += 1;\n      }\n    }\n  }\n  return lexicographicIdx;\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function lexToPermutation(\n  numPieces: number,\n  lexicographicIdx: number,\n): number[] {\n  const permutation: number[] = new Array(numPieces);\n  permutation[numPieces - 1] = 0;\n  for (let i = numPieces - 2; i >= 0; i--) {\n    permutation[i] = lexicographicIdx % (numPieces - i);\n    lexicographicIdx = Math.floor(lexicographicIdx / (numPieces - i));\n    for (let j = i + 1; j < numPieces; j++) {\n      if (permutation[j] >= permutation[i]) {\n        permutation[j] = permutation[j] + 1;\n      }\n    }\n  }\n  return permutation;\n}\n", "import { Alg } from \"../../alg\";\nimport { experimental3x3x3KPuzzle, KTransformation } from \"../../kpuzzle\";\nimport type { KState } from \"../../kpuzzle/KState\";\n\nexport function puzzleOrientationIdx(state: KState): [number, number] {\n  const idxU = state.stateData[\"CENTERS\"].pieces[0];\n  const idxD = state.stateData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = state.stateData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nfunction puzzleOrientationCache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientationIdx(transformation.toKState());\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalizePuzzleOrientation(state: KState): KState {\n  const [idxU, idxL] = puzzleOrientationIdx(state);\n  const orientationTransformation = puzzleOrientationCache()[idxU][idxL];\n  return state.applyTransformation(orientationTransformation);\n}\n\n// TODO: combine with `orientPuzzle`?\nexport function reorientPuzzle(\n  state: KState,\n  idxU: number,\n  idxL: number,\n): KState {\n  return state.applyTransformation(\n    puzzleOrientationCache()[idxU][idxL].invert(),\n  );\n}\n", "import { experimental3x3x3KPuzzle, KState } from \"../../kpuzzle\";\nimport {\n  identityPermutation,\n  lexToPermutation,\n  maskToOrientations,\n  orientationsToMask,\n  permutationToLex,\n} from \"./orbit-indexing\";\nimport {\n  normalizePuzzleOrientation,\n  puzzleOrientationIdx,\n  reorientPuzzle,\n} from \"./puzzle-orientation\";\n\ntype Binary3x3x3State = ArrayBuffer;\n\n// Bit lengths of the encoded components, in order.\nconst BIT_LENGTHS = [29, 12, 16, 13, 3, 2, 1, 12];\n\n// These fields are sorted by the order in which they appear in the binary format.\nexport interface Binary3x3x3Components {\n  epLex: number; // 29 bits, edge permutation\n  eoMask: number; // 12 bits, edge orientation\n  cpLex: number; // 16 bits, corner permutation\n  coMask: number; // 13 bits, corner orientation\n  poIdxU: number; // 3 bits, puzzle orientation (U face)\n  poIdxL: number; // 2 bits, puzzle orientation (L face)\n  moSupport: number; // 1 bit, center orientation support\n  moMask: number; // 12 bits, center orientation\n}\n\n// There are various clever ways to do this, but this is simple and efficient.\nfunction arraySum(arr: number[]): number {\n  let total = 0;\n  for (const entry of arr) {\n    total += entry;\n  }\n  return total;\n}\n\n// Due to limitations in JS bit operations, this is unsafe if any of the bit lengths span across the contents of more than 4 bytes.\n// - Safe: [8, 32]\n// - Unsafe: [4, 32, 4]\n// - Unsafe: [40, 4]\nfunction splitBinary(bitLengths: number[], buffy: ArrayBuffer): number[] {\n  const u8buffy = new Uint8Array(buffy);\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  const values: number[] = [];\n  for (const bitLength of bitLengths) {\n    while (bits < bitLength) {\n      accum = (accum << 8) | u8buffy[at++];\n      bits += 8;\n    }\n    values.push((accum >> (bits - bitLength)) & ((1 << bitLength) - 1));\n    bits -= bitLength;\n  }\n  return values;\n}\n\n// See above for safety notes.\nfunction concatBinary(bitLengths: number[], values: number[]): ArrayBuffer {\n  const buffy = new Uint8Array(Math.ceil(arraySum(bitLengths) / 8));\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  for (let i = 0; i < bitLengths.length; i++) {\n    accum = (accum << bitLengths[i]) | values[i];\n    bits += bitLengths[i];\n    while (bits >= 8) {\n      buffy[at++] = accum >> (bits - 8);\n      bits -= 8;\n    }\n  }\n  if (bits > 0) {\n    buffy[at++] = accum << (8 - bits);\n  }\n  return buffy;\n}\n\n// 0x111 (for idxU) means \"not supported\"\nfunction supportsPuzzleOrientation(components: Binary3x3x3Components): boolean {\n  return components.poIdxU !== 7;\n}\n\nexport function reid3x3x3ToBinaryComponents(\n  state: KState,\n): Binary3x3x3Components {\n  const normedState = normalizePuzzleOrientation(state);\n\n  const epLex = permutationToLex(normedState.stateData[\"EDGES\"].pieces);\n  const eoMask = orientationsToMask(\n    2,\n    normedState.stateData[\"EDGES\"].orientation,\n  );\n  const cpLex = permutationToLex(normedState.stateData[\"CORNERS\"].pieces);\n  const coMask = orientationsToMask(\n    3,\n    normedState.stateData[\"CORNERS\"].orientation,\n  );\n  const [poIdxU, poIdxL] = puzzleOrientationIdx(state);\n  const moSupport = 1; // Required for now.\n  const moMask = orientationsToMask(\n    4,\n    normedState.stateData[\"CENTERS\"].orientation,\n  );\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\nexport function binaryComponentsToTwizzleBinary(\n  components: Binary3x3x3Components,\n): Binary3x3x3State {\n  const { epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask } =\n    components;\n\n  return concatBinary(BIT_LENGTHS, [\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  ]);\n}\n\nexport function reid3x3x3ToTwizzleBinary(state: KState): Binary3x3x3State {\n  const components: Binary3x3x3Components = reid3x3x3ToBinaryComponents(state);\n  return binaryComponentsToTwizzleBinary(components);\n}\n\nexport function twizzleBinaryToBinaryComponents(\n  buffer: ArrayBuffer,\n): Binary3x3x3Components {\n  const [epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask] =\n    splitBinary(BIT_LENGTHS, buffer);\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\nexport function binaryComponentsToReid3x3x3(\n  components: Binary3x3x3Components,\n): KState {\n  if (components.moSupport !== 1) {\n    throw new Error(\"Must support center orientation.\");\n  }\n\n  const normedState = new KState(experimental3x3x3KPuzzle, {\n    EDGES: {\n      pieces: lexToPermutation(12, components.epLex),\n      orientation: maskToOrientations(2, 12, components.eoMask),\n    },\n    CORNERS: {\n      pieces: lexToPermutation(8, components.cpLex),\n      orientation: maskToOrientations(3, 8, components.coMask),\n    },\n    CENTERS: {\n      pieces: identityPermutation(6),\n      orientation: maskToOrientations(4, 6, components.moMask),\n    },\n  });\n\n  if (!supportsPuzzleOrientation(components)) {\n    return normedState;\n  }\n\n  return reorientPuzzle(normedState, components.poIdxU, components.poIdxL);\n}\n\n// Returns a list of error string.\n// An empty list means validation success.\nfunction validateComponents(components: Binary3x3x3Components): string[] {\n  const errors = [];\n  if (components.epLex < 0 || components.epLex >= 479001600) {\n    errors.push(`epLex (${components.epLex}) out of range`);\n  }\n  if (components.cpLex < 0 || components.cpLex >= 40320) {\n    errors.push(`cpLex (${components.cpLex}) out of range`);\n  }\n  if (components.coMask < 0 || components.coMask >= 6561) {\n    errors.push(`coMask (${components.coMask}) out of range`);\n  }\n  if (components.poIdxU < 0 || components.poIdxU >= 6) {\n    // 0x111 (for idxU) means \"not supported\"\n    if (supportsPuzzleOrientation(components)) {\n      errors.push(`poIdxU (${components.poIdxU}) out of range`);\n    }\n  }\n  // The following cannot be (f decoded from binary properl) out of rangey.\n  if (components.eoMask < 0 || components.eoMask >= 4096) {\n    errors.push(`eoMask (${components.eoMask}) out of range`);\n  }\n  if (components.moMask < 0 || components.moMask >= 4096) {\n    errors.push(`moMask (${components.moMask}) out of range`);\n  }\n  if (components.poIdxL < 0 || components.poIdxL >= 4) {\n    errors.push(`poIdxL (${components.poIdxL}) out of range`);\n  }\n  if (components.moSupport < 0 || components.moSupport >= 2) {\n    errors.push(`moSupport (${components.moSupport}) out of range`);\n  }\n  return errors;\n}\n\nexport function twizzleBinaryToReid3x3x3(buffy: ArrayBuffer): KState {\n  const components = twizzleBinaryToBinaryComponents(buffy);\n  const errors = validateComponents(components);\n  if (errors.length !== 0) {\n    throw new Error(`Invalid binary state components: ${errors.join(\", \")}`);\n  }\n  return binaryComponentsToReid3x3x3(components);\n}\n", "export function bufferToSpacedHex(buffer: ArrayBuffer): string {\n  // buffer is an ArrayBuffer\n  return (\n    Array.prototype.map.call(new Uint8Array(buffer), (x: number) =>\n      (\"00\" + x.toString(16)).slice(-2),\n    ) as string[]\n  ).join(\" \");\n}\n\nexport function spacedHexToBuffer(hex: string): Uint8Array {\n  return new Uint8Array(hex.split(\" \").map((c) => parseInt(c, 16)));\n}\n"],
  "mappings": "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",
  "names": []
}
